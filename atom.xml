<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青青子衿</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hexuanzhang.github.io/"/>
  <updated>2018-03-05T15:58:43.551Z</updated>
  <id>https://hexuanzhang.github.io/</id>
  
  <author>
    <name>青青子衿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS Tips</title>
    <link href="https://hexuanzhang.github.io/2018/03/05/CSS-Tips/"/>
    <id>https://hexuanzhang.github.io/2018/03/05/CSS-Tips/</id>
    <published>2018-03-05T14:15:18.000Z</published>
    <updated>2018-03-05T15:58:43.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-Tips"><a href="#CSS-Tips" class="headerlink" title="CSS Tips"></a>CSS Tips</h2><h3 id="改变输入框光标颜色"><a href="#改变输入框光标颜色" class="headerlink" title="改变输入框光标颜色"></a>改变输入框光标颜色</h3><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/caret-color" target="_blank" rel="noopener">caret-color</a></p><blockquote><p><code>caret-color</code> 属性不仅对 <code>input</code> 和 <code>textarea</code> 有效，对设置了 <code>contenteditable</code> 属性的 HTML 标签也同样适用</p></blockquote><p><a href="https://codepen.io/zhanghx/pen/yvWZwp" target="_blank" rel="noopener">Demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input,</span><br><span class="line">textarea,</span><br><span class="line">[contenteditable] &#123;</span><br><span class="line">color: #333; /* 文本颜色 */</span><br><span class="line">caret-color: #03a9f4; /* 光标颜色 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟光标</p><blockquote><p><code>caret-color</code> 属性的<a href="https://caniuse.com/#search=caret-color" target="_blank" rel="noopener">兼容性</a>不是很理想，对于不支持的浏览器，可以做兼容处理</p><p> <code>color</code> 指定光标颜色，然后通过 <code>::first-line</code> 伪元素增加优先级设置文字颜色。这种写法也存在兼容问题</p><blockquote><p>对 <code>textarea</code> 元素无效</p><p>win10 下 Edge 浏览器无效</p></blockquote></blockquote><p><a href="https://codepen.io/zhanghx/pen/xYNejd" target="_blank" rel="noopener">Demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input,</span><br><span class="line">texxarea,</span><br><span class="line">[contenteditable] &#123;</span><br><span class="line"></span><br><span class="line">  color: #03a9f4;</span><br><span class="line">  </span><br><span class="line">  &amp;::first-line &#123;</span><br><span class="line">      color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>兼容性写法</p><p><a href="https://codepen.io/zhanghx/pen/oERRMV" target="_blank" rel="noopener">Demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input,</span><br><span class="line">texxarea,</span><br><span class="line">[contenteditable] &#123;</span><br><span class="line"></span><br><span class="line">  color: #03a9f4;</span><br><span class="line"></span><br><span class="line">  &amp;::first-line &#123;</span><br><span class="line">      color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@supports (caret-color: #03a9f4) &#123;</span><br><span class="line">  input,</span><br><span class="line">  textarea,</span><br><span class="line">  [contenteditable] &#123;</span><br><span class="line">      color: #333; /* 文本颜色 */</span><br><span class="line">      caret-color: #03a9f4; /* 光标颜色 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS-Tips&quot;&gt;&lt;a href=&quot;#CSS-Tips&quot; class=&quot;headerlink&quot; title=&quot;CSS Tips&quot;&gt;&lt;/a&gt;CSS Tips&lt;/h2&gt;&lt;h3 id=&quot;改变输入框光标颜色&quot;&gt;&lt;a href=&quot;#改变输入框光标颜色&quot; class=&quot;he
      
    
    </summary>
    
      <category term="css" scheme="https://hexuanzhang.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://hexuanzhang.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastChannel</title>
    <link href="https://hexuanzhang.github.io/2018/03/02/BroadcastChannel/"/>
    <id>https://hexuanzhang.github.io/2018/03/02/BroadcastChannel/</id>
    <published>2018-03-02T15:49:38.000Z</published>
    <updated>2018-03-02T15:50:20.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h2><blockquote><p>  <code>BroadcastChannel</code> 允许同源脚本跨 <code>window / tab</code>、<code>iframe</code>、<code>web worker</code> 进行多对多通信</p></blockquote><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><code>BroadcastChannel</code> 构造函数只接受参数，那就是渠道名称（channel name）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const channel = new BroadcastChannel(&apos;name&apos;);</span><br></pre></td></tr></table></figure><p><code>BroadcastChannel</code> 接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Constructor(DOMString name), Exposed=(Window,Worker)]</span><br><span class="line">interface BroadcastChannel : EventTarget &#123;</span><br><span class="line">    readonly attribute DOMString name;</span><br><span class="line">    void postMessage(any message);</span><br><span class="line">    void close();</span><br><span class="line">    attribute EventHandler onmessage;</span><br><span class="line">    attribute EventHandler onmessageerror;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>name</code>：频道名称，用来区分不同频道（跨频道不可通信） </li><li><code>postMessage</code>：广播频道信息</li><li><code>onmessage</code>：接受广播信息</li><li><code>close</code>：停止接受频道信息  </li></ul><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p>每个页面创建相同频道名称的 <code>BraodcastChannel</code> 对象并进入频道，通过 <code>onmessage</code> 来接受频道广播的信息，通过 <code>postMessage()</code> 方法可以广播信息给所有加入当前频道的页面。</p><p>本质上，这是在特定频道下的全双工（双向）通信，每个页面都可以在频道中彼此收发任何消息。<strong>不可跨频道通信</strong>。</p><p><code>BroadcastChannel</code> 对象的 <code>close()</code> 只是调用者自己停止接受广播信息，不影响其它页面。</p><p><strong>还有一点需要注意的事，消息事件中传输的对象并不是深拷贝，传输的是对象的引用地址</strong></p><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-02-BroadcastChannel.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// page A</span><br><span class="line">const a = new BroadcastChannel(&apos;app&apos;);</span><br><span class="line">const list = [&apos;A&apos;, &apos;B&apos;];</span><br><span class="line">a.postMessage(&#123; list &#125;);</span><br><span class="line"></span><br><span class="line">// page B</span><br><span class="line">const b = new BroadcastChannel(&apos;app&apos;)</span><br><span class="line">b.onmessage = function (event) &#123;</span><br><span class="line">    event.data.list.push(&apos;C&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>目前除了 <code>BroadcastChannel</code> 外，有好几种信息发送技术，如 <code>WebSockets</code>、<code>SharedWorker</code>、<code>MessageChannel</code> 和 <code>window.postMessage()</code>。不同的技术，适合不同的场景，下面简单的对比下。</p><ul><li><p><code>BroadcastChannel</code> vs <code>postMessage()</code></p><ul><li>前者必须在同域传输，后者允许跨域传输数据</li><li>前者传输的是对象引用地址，后者传输的是经过  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noopener">structured clone algorithm</a>  后的数据</li></ul></li><li><p><code>BroadcastChannel</code> vs <code>SharedWorker()</code></p><ul><li>前者只是简单的在多个页面或 <code>worker</code> 之间进行数据传输，后者在服务器与客户端之间的状态管理、资源同步方面更具优势</li></ul></li><li><p><code>BroadcastChannel</code> vs <code>MessagChannel</code></p><ul><li>两者之间最大的区别在于前者是多对多通讯，后者是一对一通讯</li></ul></li></ul><h3 id="polyfills"><a href="#polyfills" class="headerlink" title="polyfills"></a>polyfills</h3><ul><li><a href="https://gist.github.com/alexis89x/041a8e20a9193f3c47fb" target="_blank" rel="noopener">https://gist.github.com/alexis89x/041a8e20a9193f3c47fb</a></li><li><a href="https://gist.github.com/inexorabletash/52f437d1451d12145264" target="_blank" rel="noopener">https://gist.github.com/inexorabletash/52f437d1451d12145264</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://caniuse.com/#search=BroadcastChannel" target="_blank" rel="noopener">caniuse</a></li><li><a href="https://developers.google.com/web/updates/2016/09/broadcastchannel" target="_blank" rel="noopener">BroadcastChannel API: A Message Bus for the Web</a></li><li><a href="https://html.spec.whatwg.org/multipage/web-messaging.html#broadcasting-to-other-browsing-contexts" target="_blank" rel="noopener">BroadcastChannel spec</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BroadcastChannel&quot;&gt;&lt;a href=&quot;#BroadcastChannel&quot; class=&quot;headerlink&quot; title=&quot;BroadcastChannel&quot;&gt;&lt;/a&gt;BroadcastChannel&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 
      
    
    </summary>
    
      <category term="H5" scheme="https://hexuanzhang.github.io/categories/H5/"/>
    
    
      <category term="H5" scheme="https://hexuanzhang.github.io/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>web worker</title>
    <link href="https://hexuanzhang.github.io/2018/03/02/worker/"/>
    <id>https://hexuanzhang.github.io/2018/03/02/worker/</id>
    <published>2018-03-02T15:46:11.000Z</published>
    <updated>2018-03-02T15:46:57.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h2><p>众所周知，<code>JavaScript</code> 是单线程，无法进行并行操作；因而 H5 中增加了 <code>Web Worker</code>，提供多线程解决方案；<code>Web Worker</code> 允许一段 <code>JavaScript</code> 程序运行在主线程之外的另外一个线程中</p><p>主线程与 <code>worker</code>之间，以及 <code>worker</code> 与 <code>worker</code> 之间通过 <code>postMessage()</code>、<code>message</code> 来通信</p><p><code>web worker</code> 分两种类型：一种是专用线程（<code>dedicated web worker</code>），另一种是共享线程（<code>shared web worker</code>）；前者被创建它的页面访问，后者在多个页面间共享</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker" target="_blank" rel="noopener">构建</a></h3><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-01-073748.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const worker = new worker(url, options); // 专用线程</span><br><span class="line"></span><br><span class="line">const sharedWorker = new SharedWorker(url, options); // 共享线程</span><br></pre></td></tr></table></figure><ul><li><p><code>url</code> 必须遵循<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略</a></p></li><li><p>可以通过 <code>options</code> 指定 <code>worker</code> 名称</p></li></ul><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-01-073437.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// main</span><br><span class="line">const worker = new worker(url);</span><br><span class="line">worker.postMessage(message, transferList);</span><br><span class="line"></span><br><span class="line">// worker</span><br><span class="line">self.onmessage = (event) = &#123;</span><br><span class="line">    console.info(event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程和 <code>worker</code> 线程之间通过通过互相调用 <code>sendMessage</code>、<code>onMessage</code> 来通信的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessagePort" target="_blank" rel="noopener">MessagePort</a> 对象进行通信；专用线程使用隐式的 <code>MessagePort</code> 实例，专用线程被创建时，MessagePort 的端口消息队列便被主动启用；这与共享线程的 <code>start()</code> 效果一样 </p><p><code>MessagePort</code> 通信方式是深拷贝，即是传值而不是地址，子线程对通信内容的修改，不会影响到主线程；浏览器内部</p><p>线程之间传输的数据类型可以是字符串、对象，也可以是二进制数据，如 <code>File</code>、<code>Blob</code>、<code>ArrayBuffer</code>等</p><p>线程之间传输数据的方式有两种：一种是采用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessagePort" target="_blank" rel="noopener">MessagePort</a> 方式进行通信（深拷贝），浏览器内部通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noopener">structured clone algorithm</a> ，将发送端的数据进行序列化并拷贝，接收端收到的数据进行反序列化，这样两端的数据在发生更改时不会相互影响；另一种采用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">Transferable Objects</a> 方式进行通信（转移），这种方式主要用于二进制数据的传递，它对数据不做任何拷贝而是直接将数据值的引用转移给数据接收端，而数据发送端不会再持有该数据的引用，这样可以防止出现多个线程同时修改数据</p><p>使用 <code>JSON.stringify</code> 序列化需要传输的数据，根据 Nolan Lawson 的<a href="https://nolanlawson.com/2016/02/29/high-performance-web-worker-messages/" target="_blank" rel="noopener">测试</a>结果，证明传输 <code>stringify</code> 后的数据比传输原始数据更优</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在 <code>Chrome</code> 中打开 <code>chrome://inspect/#workers</code></p><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-01-083931.png" alt=""></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/AbstractWorker/onerror" target="_blank" rel="noopener">onerror</a></p><p> <code>event</code> 对象中包含发生异常的文件（<code>filename</code>）、行号（<code>lineno</code>）以及相应的错误信息（<code>message</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker.addEventListener(&apos;error&apos;, (event) = &#123;</span><br><span class="line">    console.info(`$&#123;event.filename&#125;-$&#123;event.lineno&#125;-$&#123;event.message&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/onmessageerror" target="_blank" rel="noopener">onmessageerror</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessageerror = (event) = &#123; console.dir(event); &#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>有三种方式结束 worker：</p><ul><li>主线程调用 <code>worker.terminate()</code></li><li><code>worker</code> 内部调用 <code>self.close()</code></li><li>关闭页面（捂脸）</li></ul><h3 id="sub-worker"><a href="#sub-worker" class="headerlink" title="sub worker"></a><a href="https://html.spec.whatwg.org/multipage/workers.html#delegation" target="_blank" rel="noopener">sub worker</a></h3><p><code>worker</code> 中可以创建子 <code>worker</code>，但有两点需要留意：</p><ul><li>子 <code>worker</code> 与父 <code>worker</code> 必须同源</li><li>子 <code>worker</code> 的 <code>url</code> 是相对 父 <code>worker</code>，而不是主线程</li></ul><h3 id="inline-worker"><a href="#inline-worker" class="headerlink" title="inline worker"></a>inline worker</h3><blockquote><p>  需要及时释放 <code>Blob URL</code>（<code>window.URL.revokeObjectURL(blobURL)</code>）<br>  <code>Chrome</code> 中可以在 <code>chrome://blob-internals/</code> 中查看所有的 Blob URLs</p></blockquote><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-01-clipboard-1.png" alt=""></p><h3 id="加载外部脚本"><a href="#加载外部脚本" class="headerlink" title="加载外部脚本"></a>加载外部脚本</h3><p><code>Worker</code> 线程能够访问一个全局函数 <code>importScripts()</code> 来引入外部脚本，该函数可以接受多个 <code>url</code>，<code>url</code> 必须保证同源<br>；如果加载失败，则后续代码无法执行。<br>脚本的执行顺序依照传入函数的顺序，但下载顺序不固定。这个过程是同步的，所有脚本下载并执行完，函数才会返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">importScripts();</span><br><span class="line"></span><br><span class="line">importScripts(&apos;foo.js&apos;); </span><br><span class="line"></span><br><span class="line">importScripts(&apos;foo.js&apos;, &apos;bar.js&apos;);</span><br></pre></td></tr></table></figure><h3 id="worker-执行流程"><a href="#worker-执行流程" class="headerlink" title="worker 执行流程"></a>worker 执行流程</h3><p>具体参考 <a href="http://blog.csdn.net/codigger/article/details/40581343" target="_blank" rel="noopener">Web Worker在WebKit中的实现机制</a><br><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-01-102922.jpg" alt=""></p><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p><code>Worker</code> 不同于 <code>window</code>，它运行在另一个全局作用域（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope" target="_blank" rel="noopener"><code>DedicatedWorkerGlobalScope</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorkerGlobalScope" target="_blank" rel="noopener"><code>SharedWorkerGlobalScope</code></a>）中，有些 <code>window</code> 中的属性和方法无法在 <code>worker</code> 中访问，具体可以查看这篇<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers" target="_blank" rel="noopener">文章</a>；</p><p>不允许访问的对象包括：<code>DOM</code>、<code>document</code>、<code>window</code>、<code>parent</code>、<code>LocalStorage</code></p><p>允许访问的对象包括：<code>navigator</code>、<code>location（只读）</code>、<code>XMLHttpRequest</code>、<code>setTimeout / setInterval</code>、<code>Application Cache</code></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><code>worker</code> 执行环境中 <code>self</code> 和 <code>this</code> 都指向<code>worker</code> 的全局作用域，以下三种写法效果一样<br><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-03-01-clipboard.png" alt=""></li><li><code>self</code> 也提供一系列接口，包括：<code>self.JSON</code>、<code>self.Math</code>、<code>self.console</code></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>数据运算</p><ul><li><p><a href="http://link.zhihu.com/?target=http%3A//audio.angularair.com/e/62-ngair-using-web-workers-for-high-performance-angular-2-web-app/" target="_blank" rel="noopener">Angular2.0 &amp; Web Worker</a></p><blockquote><p>  <code>Ng</code> 将繁重的计算（如 <code>dirty checking</code>）放到 <code>worker</code> 中，提升渲染性能</p></blockquote></li><li><p><a href="http://link.zhihu.com/?target=http%3A//web-perf.github.io/react-worker-dom/" target="_blank" rel="noopener">React &amp; Web Worker</a></p><blockquote><p>  <code>React</code> 将 <code>dom diff</code> 移到 <code>worker</code> 中计算，再将计算结果发给主线程</p></blockquote></li><li><p><a href="http://link.zhihu.com/?target=https%3A//github.com/chikeichan/redux-worker" target="_blank" rel="noopener">redux &amp; Web Worker</a></p><blockquote><p>  <code>Redux</code> 中 <code>reducer</code> 计算状态的部分移到 <code>Worker</code> 中</p></blockquote></li></ul></li><li>大量数据的检索、分析</li><li>图像处理</li><li>音频 / 视频解码</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Using Web Workers</a></li><li><a href="https://www.html5rocks.com/en/tutorials/workers/basics/" target="_blank" rel="noopener">The Basics of Web Workers</a></li><li><a href="https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a" target="_blank" rel="noopener">How JavaScript works: The building blocks of Web Workers + 5 cases when you should use them</a></li><li><a href="https://html.spec.whatwg.org/multipage/workers.html" target="_blank" rel="noopener">spec</a></li><li><a href="http://www.alloyteam.com/2015/11/deep-in-web-worker" target="_blank" rel="noopener">深入理解 Web Worker</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-worker&quot;&gt;&lt;a href=&quot;#web-worker&quot; class=&quot;headerlink&quot; title=&quot;web worker&quot;&gt;&lt;/a&gt;web worker&lt;/h2&gt;&lt;p&gt;众所周知，&lt;code&gt;JavaScript&lt;/code&gt; 是单线程，无法进行
      
    
    </summary>
    
      <category term="H5" scheme="https://hexuanzhang.github.io/categories/H5/"/>
    
    
      <category term="H5" scheme="https://hexuanzhang.github.io/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>history</title>
    <link href="https://hexuanzhang.github.io/2018/03/01/history/"/>
    <id>https://hexuanzhang.github.io/2018/03/01/history/</id>
    <published>2018-03-01T14:12:02.000Z</published>
    <updated>2018-03-01T14:12:45.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><blockquote><p>  在 DOM 中，window 对象中有个 history 对象可以用来访问浏览器的历史记录；在HTML5中，更可以通过它来操作历史记录</p></blockquote><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-02-28-022827.png" alt=""></p><h4 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h4><blockquote><p>  返回上一个访问页，与浏览器的后退按钮功能一样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.back(); //回退</span><br></pre></td></tr></table></figure><h4 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h4><blockquote><p>  向前访问新的防问页，与浏览器的前进按钮功能一样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.forward(); // 前进</span><br></pre></td></tr></table></figure><h4 id="go"><a href="#go" class="headerlink" title="go()"></a>go()</h4><blockquote><p>  传递一个数字（正数代表前进，负数代表回退），加载相对于当前页的指定页面（当前历史记录中）</p><p>  <code>go(-1)</code> 和 <code>back()</code> 的区别在于前者会丢失原页面表单内容</p><p>  不同浏览器对于 <code>go(-1)</code> 的表现不一致，Chrome、Firefox  会刷新回退后的页面并重新请求数据，而 Safari 只会回退到原页面但不做任何操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.go(1); //前进一页</span><br><span class="line">history.go(0); // 刷新当前页</span><br><span class="line">history.go(-2); // 回退两页</span><br></pre></td></tr></table></figure><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><blockquote><p>  返回历史记录的长度</p></blockquote><h4 id="pushState"><a href="#pushState" class="headerlink" title="pushState()"></a>pushState()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushState(stateObj, title, URL);</span><br></pre></td></tr></table></figure><blockquote><p>  <code>state object</code>：与新的历史记录关联的可序列化对象，大小限制为 640k 字符，超过最大限制会抛异常</p><p>  <code>title</code>：新页面标题，目前不支持；建议传空字符，防止以后该方法发生改变</p><p>  <code>URL</code>：可选参数，新历史记录路径；可以是相对路径，也可以是绝对路径，但必须同源；如果不传，则默认是当前页面路径</p><p>  也可以通过 <code>hash</code> 来实现添加历史记录且不刷新页面，也有对应伪 URL 相关数据</p><p>  两者对比，<code>pushState</code> 有一定的优势</p><blockquote><p>  1、使用 <code>hash</code> 方式，如果不改变 <code>hash</code> 则不会产生新的历史记录，也不会触发 <code>onhashchange</code> 事件；而 <code>pushState</code> 即使插入的是相同 <code>URL</code>，也会产生新的历史记录</p><p>  2、使用 <code>hash</code> 方式，需要将传输数据编码为字符串；而 <code>pushState</code> 可以传递任何类型数据</p></blockquote></blockquote><h4 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState()"></a>replaceState()</h4><blockquote><p>  <code>replaceState()</code> 与 <code>pushState()</code> 基本一致，不用的是，前者是修改历史记录，后者是创建新的历史记录</p></blockquote><h4 id="popstate-event"><a href="#popstate-event" class="headerlink" title="popstate event"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate" target="_blank" rel="noopener">popstate event</a></h4><blockquote><p>  <code>PopStateEvent</code> 包含当前页面的 <code>state</code></p><p>  <strong>浏览器的回退和前进操作会触发该事件，但是 <code>pushState()</code> 和 <code>replaceState()</code> 不会触发</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate = (event) = &gt; &#123;</span><br><span class="line">    console.info(event.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://caniuse.com/#search=popstate" target="_blank" rel="noopener">caniuse</a></li><li><a href="https://css-tricks.com/using-the-html5-history-api/" target="_blank" rel="noopener">Using the HTML5 History API</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;history&quot;&gt;&lt;a href=&quot;#history&quot; class=&quot;headerlink&quot; title=&quot;history&quot;&gt;&lt;/a&gt;history&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  在 DOM 中，window 对象中有个 history 对象可以用来
      
    
    </summary>
    
      <category term="H5" scheme="https://hexuanzhang.github.io/categories/H5/"/>
    
    
      <category term="H5" scheme="https://hexuanzhang.github.io/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>react-router-dom vs react-router</title>
    <link href="https://hexuanzhang.github.io/2018/03/01/react-router/"/>
    <id>https://hexuanzhang.github.io/2018/03/01/react-router/</id>
    <published>2018-03-01T14:06:34.000Z</published>
    <updated>2018-03-01T14:09:23.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-router-dom-vs-react-router"><a href="#react-router-dom-vs-react-router" class="headerlink" title="react-router-dom vs react-router"></a>react-router-dom vs react-router</h2><blockquote><p>  React Router V4 相对 V2/V3 几乎完全重写了，遵循 Just Component 的 API 设计理念</p><p>  <code>react-router V4</code> 分成了三个包：<code>react-router-dom(for web)</code>、<code>react-router-native(for #native)</code>、<code>react-router(core)</code></p><p>  也就是说，<code>react-router-dom</code> 是在 <code>react-router</code> 基础上添加了一些在浏览器环境下的特定功能，如 <code>Link</code>、<code>BrowserRouter</code> 、<code>HashRouter</code> 等</p><blockquote><p>  <code>BrowserRouter</code>：通过 <code>pushState</code> 和 <code>replaceState</code> 构建路由<br>  <code>HashRouter</code>：通过 <code>location.hash</code> 和 <code>hashchange</code> 构建路由</p></blockquote><p>  通过 npm 安装 <code>react-router-dom</code> 时发现其依赖 <code>react-router</code>，也就是说不需要显示安装 <code>react-router</code></p></blockquote><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2018-02-28-082357.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 写法 1</span><br><span class="line">import &#123; Swtich, Route, Router, HashHistory, Link &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">// 写法 2</span><br><span class="line">import &#123; Switch, Route, Router &#125; from &apos;react-router&apos;;</span><br><span class="line">import &#123; HashHistory, Link &#125; from &apos;react-router-dom&apos;;</span><br></pre></td></tr></table></figure><p>对上面两种写法做个简单的分析，两种写法唯一的区别在于 <code>Switch</code>、<code>Route</code> 及 <code>Router</code> 的导入源不一致。<br>通过查看源码，发现在 <code>react-router-dom</code> 中 <a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/Switch.js" target="_blank" rel="noopener"><code>Switch</code></a>、<a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/Route.js" target="_blank" rel="noopener"><code>Route</code></a> 及 <a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/Router.js" target="_blank" rel="noopener"><code>Router</code></a> 都是从 <code>react-router</code> 中导入了相应的组件，然后重新导出而已，并没有特殊的处理逻辑。<br>因此两种写法其实效果一样，写法 1 更简洁些。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/ReactTraining/react-router/issues/4648" target="_blank" rel="noopener">what’s the diff between react-router-dom &amp; react-router</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-router-dom-vs-react-router&quot;&gt;&lt;a href=&quot;#react-router-dom-vs-react-router&quot; class=&quot;headerlink&quot; title=&quot;react-router-dom vs react-ro
      
    
    </summary>
    
      <category term="react" scheme="https://hexuanzhang.github.io/categories/react/"/>
    
      <category term="react-router" scheme="https://hexuanzhang.github.io/categories/react/react-router/"/>
    
    
      <category term="react" scheme="https://hexuanzhang.github.io/tags/react/"/>
    
      <category term="react-router" scheme="https://hexuanzhang.github.io/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>hexo 部署失败解决方法</title>
    <link href="https://hexuanzhang.github.io/2018/02/28/hexo-%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://hexuanzhang.github.io/2018/02/28/hexo-部署失败解决方法/</id>
    <published>2018-02-28T15:07:30.000Z</published>
    <updated>2018-02-28T15:10:38.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-部署失败解决方法"><a href="#Hexo-部署失败解决方法" class="headerlink" title="Hexo 部署失败解决方法"></a>Hexo 部署失败解决方法</h2><p>昨天写博客时发现无法部署，执行 <code>hexo d</code> 出现错误，提示 <code>fatal: could not read Username for &#39;https://github.com&#39;: No error</code>。</p><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180228/j3mlBal3E4.png?imageslim" alt="mark"></p><p><code>No error</code> ？蜜汁无解！</p><p>后来经过查询，发现是由于 <a href="https://githubengineering.com/crypto-removal-notice/" target="_blank" rel="noopener">github 停用了TLS1.0/1.1</a>，因而 HTTPS 提交不上去。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>有四种解决方案，推荐用第二种方案（更新 git）</p></blockquote><ul><li><p>将 HTTPS 改用为 SSH 方式</p></li><li><p><a href="https://git-scm.com/download/" target="_blank" rel="noopener">下载最新版（v2.16.2）git</a></p></li><li><p>不更新 git，单独安装<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/" target="_blank" rel="noopener">Git Credential Manager for Windows</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo-部署失败解决方法&quot;&gt;&lt;a href=&quot;#Hexo-部署失败解决方法&quot; class=&quot;headerlink&quot; title=&quot;Hexo 部署失败解决方法&quot;&gt;&lt;/a&gt;Hexo 部署失败解决方法&lt;/h2&gt;&lt;p&gt;昨天写博客时发现无法部署，执行 &lt;code&gt;hexo
      
    
    </summary>
    
      <category term="hexo" scheme="https://hexuanzhang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hexuanzhang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 不常用属性整理</title>
    <link href="https://hexuanzhang.github.io/2018/02/27/CSS3-%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%95%B4%E7%90%86/"/>
    <id>https://hexuanzhang.github.io/2018/02/27/CSS3-不常用属性整理/</id>
    <published>2018-02-27T15:07:06.000Z</published>
    <updated>2018-02-28T15:13:21.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="box-decoration-break"><a href="#box-decoration-break" class="headerlink" title="box-decoration-break"></a><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-decoration-break" target="_blank" rel="noopener">box-decoration-break</a></h2><blockquote><p><code>box-decoration-break</code> 属性属于 CSS 片段模块（<a href="https://www.w3.org/TR/css-break-3/#break-decoration" target="_blank" rel="noopener">CSS Fragmentation Module Level 3</a>）中的一个属性，用于控制行内元素有关于 <code>padding</code>、<code>background</code>、<code>border-image</code>、<code>border</code>、<code>margin</code> 和 <code>clip</code> 属性在行内元素多行情形下的渲染形式</p><p><code>box-decoration-break</code> 属性接受两个值 <code>slice</code> 和 <code>clone</code>，其中 <code>slice</code> 是其默认值</p><blockquote><ul><li><code>clone</code>：每个盒子的片段都有独立的 <code>border</code> 和 <code>padding</code>，并且 <code>border-radius</code>、<code>border-image</code>、<code>box-shadow</code> 和 <code>background</code> 也都会独立运用于元素的每个片段</li><li><code>slice</code>：<code>border</code>和 <code>padding</code> 不会运用于元素被打断的片段中（除首行和末行），同时 <code>border-radius</code> 也只会运用于元素的四个顶角，对于打断片段之处并不会有任何的效果；另外 <code>border-image</code> 和 <code>background</code> 会被运用于整个元素</li></ul></blockquote><p>该属于只能用于 <code>inline</code> 元素，且不能搭配 <code>float</code> 和 <code>position（取值为 absolute 或 fixed）</code> 一起使用</p></blockquote><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li><a href="https://codepen.io/zhanghx/pen/wyQRZP" target="_blank" rel="noopener">Demo</a></li><li><a href="https://caniuse.com/#search=box-decoration-break" target="_blank" rel="noopener">兼容性</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;box-decoration-break&quot;&gt;&lt;a href=&quot;#box-decoration-break&quot; class=&quot;headerlink&quot; title=&quot;box-decoration-break&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer
      
    
    </summary>
    
      <category term="css3" scheme="https://hexuanzhang.github.io/categories/css3/"/>
    
    
      <category term="css3" scheme="https://hexuanzhang.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝的实现方式</title>
    <link href="https://hexuanzhang.github.io/2018/02/11/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://hexuanzhang.github.io/2018/02/11/浅拷贝和深拷贝的实现方式/</id>
    <published>2018-02-11T15:30:29.000Z</published>
    <updated>2018-02-12T01:55:30.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const shallowCopy = (obj) =&gt; &#123;</span><br><span class="line">    let result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for(let property in obj) &#123;</span><br><span class="line">        obj.hasOwnProperty(property) &amp;&amp; (result[property] = obj[property]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; a: 1, b: [2, 3], c: new Date(), d: new RegExp(&apos;^/d&#123;1, 6&#125;&apos;) &#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">setTimeout(() =&gt; console.log(shallowCopy(obj)), 1000);</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: &#123;&#125;, b: [2, 3], c: new Date(), d: new RegExp(&apos;^/d&#123;1, 6&#125;&apos;) &#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">setTimeout(() =&gt; console.log(Object.assign(&#123;&#125;, obj)), 1000);</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><blockquote><p>针对纯 JSON 数据对象的深拷贝，可以使用 JSON 全局对象的 <code>parse</code> 和 <code>stringify</code> 方法来实现</p><p>不过这种方法有一定的局限性，它能正确处理的对象只有 Number, String, Boolean, Array, 及扁平对象，即那些能够被 json 直接表示的数据结构</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const deepCopy = obj =&gt; JSON.parse(JSON.stringify(obj));</span><br><span class="line"></span><br><span class="line">const obj = &#123; a: 1, date: new Date()&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">setTimeout(() =&gt; console.log(deepCopy(obj)), 1000);</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180211/k3geK1AjGA.png?imageslim" alt="mark"></p><h3 id="Structured-Clone"><a href="#Structured-Clone" class="headerlink" title="Structured Clone"></a>Structured Clone</h3><blockquote><p><a href="https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal" target="_blank" rel="noopener">Structured Clone</a> 是一种已存在的运算法则，它可以将对象从一种场景传递至另一场景，如通过 <code>postMessage</code> 方法可以发送信息至其他 <code>window</code> 或 <code>webWorker</code>；它不仅可以处理循环对象，还支持<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#Supported_types" target="_blank" rel="noopener">一系列的数据类型</a></p><p>我们可以通过这种方式来间接地实现深拷贝，下面介绍具体的实现方法：</p></blockquote><h4 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h4><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API" target="_blank" rel="noopener">Channel Messaging</a> 可以创建消息通道，并通过消息通道的端口号来实现数据传输；发送和接受这个过程，就实现了对象的深拷贝</p><p>局限性：这种方式是异步的，有时候我们需要同步拷贝</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const structuralClone = (obj) =&gt; &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        const &#123; port1, port2 &#125; = new MessageChannel();</span><br><span class="line">        port2.onmessage = ev =&gt; resolve(ev.data);</span><br><span class="line">        port1.postMessage(obj);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123; a: &#123; status: false &#125; &#125;,</span><br><span class="line">    _obj = null;</span><br><span class="line"></span><br><span class="line">structuralClone(obj).then(obj =&gt; _obj = obj);</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180211/h096BLehl2.png?imageslim" alt="mark"></p><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><blockquote><p>众所周知，<code>history.pushState()</code> 方法需要传递一个 <code>state</code>  状态对象；我们可以通过赋值，然后再取值的方式来实现深拷贝</p><p>当然，为了不产生新的历史记录，可以使用 <code>history.replaceState()</code> 方法</p><p>局限性：IOS9.3 中 Safari <a href="https://github.com/ReactTraining/history/issues/291" target="_blank" rel="noopener">限制</a> 30s 内至多只能调用 100 次 <code>replaceState()</code> 方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const structuralClone = (obj) =&gt; &#123;</span><br><span class="line">    const oldState = history.state;</span><br><span class="line">    history.replaceState(obj, document.title);</span><br><span class="line"></span><br><span class="line">    const copy = history.state;</span><br><span class="line">    history.replaceState(oldState, document.title);</span><br><span class="line"></span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; a: &#123; status: false &#125; &#125;,</span><br><span class="line">    _obj = structuralClone(obj);</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180211/8HFI66aki5.png?imageslim" alt="mark"></p><h4 id="Notification-API"><a href="#Notification-API" class="headerlink" title="Notification API"></a>Notification API</h4><blockquote><p>在发送桌面通知时，需要传递 <code>data</code> 数据，我们可以在这个 <code>data</code> 属性上做文章</p><p>局限性：这种方式需要通过浏览器授权，效率上会低一些；另外，Safari <a href="https://developer.mozilla.org/en-US/docs/Web/API/notification/data" target="_blank" rel="noopener">不支持</a> <code>Notification.data</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const structuralClone = (obj) =&gt; &#123;</span><br><span class="line">    return new Notification(&apos;&apos;, &#123; data: obj, silent: true &#125;).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; a: &#123; status: false &#125; &#125;,</span><br><span class="line">    _obj = structuralClone(obj);</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180211/D10CGeI1jA.png?imageslim" alt="mark"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://dassur.ma/things/deep-copy/#performance-extravaganza" target="_blank" rel="noopener">Deep-copying in JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h2&gt;&lt;h3 id=&quot;循环遍历&quot;&gt;&lt;a href=&quot;#循环遍历&quot; class=&quot;headerlink&quot; title=&quot;循环遍历&quot;&gt;&lt;/a&gt;循环遍
      
    
    </summary>
    
      <category term="javascript" scheme="https://hexuanzhang.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://hexuanzhang.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>小程序页面路由</title>
    <link href="https://hexuanzhang.github.io/2018/02/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1/"/>
    <id>https://hexuanzhang.github.io/2018/02/09/小程序页面路由/</id>
    <published>2018-02-09T00:42:54.000Z</published>
    <updated>2018-02-09T00:43:25.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><blockquote><p>小程序中所有页面的路由全部由框架进行管理</p></blockquote><h3 id="页面栈"><a href="#页面栈" class="headerlink" title="页面栈"></a>页面栈</h3><blockquote><p>框架以栈的形式维护当前的所有页面。 当发生路由切换的时候，页面栈会发生相应变化</p></blockquote><table><thead><tr><th>路由方式</th><th>页面栈表现</th></tr></thead><tbody><tr><td>初始化</td><td>新页面入栈</td></tr><tr><td>打开新页面</td><td>新页面入栈</td></tr><tr><td>页面重定向</td><td>当前页面出栈，新页面入栈</td></tr><tr><td>页面返回</td><td>页面不断出栈，直到目标页，目标页入栈</td></tr><tr><td>Tab 切换</td><td>页面全部出栈，新 Tab 页入栈</td></tr><tr><td>重加载</td><td>页面全部出栈，当前页入栈</td></tr></tbody></table><h3 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a>getCurrentPages()</h3><blockquote><p>获取当前页面栈的实例，返回数组；第一个数组元素为首页，也就是栈底，最后一个数组元素为当前页，也就是栈顶</p><p><strong>不要修改页面栈，会导致路由及页面状态错误</strong></p></blockquote><h3 id="路由方式"><a href="#路由方式" class="headerlink" title="路由方式"></a>路由方式</h3><blockquote><p><code>navigateTo</code>、 <code>redirectTo</code> 只能打开非 tabBar 页面；<code>switchTab</code> 只能打开 tabBar 页面；<code>reLaunch</code> 可以打开任意页面</p><p>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar</p></blockquote><p>页面路由的触发方式及相关页面的生命周期函数如下：</p><table><thead><tr><th>路由方式</th><th>触发时机</th><th>路由前页面</th><th>路由后页面</th></tr></thead><tbody><tr><td>初始化</td><td>小程序打开的第一个页面</td><td></td><td>onLoad、onShow</td></tr><tr><td>打开新页面</td><td>调用 API <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html#wxnavigatetoobject" target="_blank" rel="noopener"><code>wx.navigateTo</code></a> 或使用组件  <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html" target="_blank" rel="noopener"><code>&lt;navigator open-type=&quot;navigateTo&quot;/&gt;</code></a></td><td>onHide</td><td>onLoad、onShow</td></tr><tr><td>页面重定向</td><td>调用 API <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html#wxredirecttoobject" target="_blank" rel="noopener"><code>wx.redirectTo</code></a> 或使用组件 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html" target="_blank" rel="noopener"><code>&lt;navigator open-type=&quot;redirectTo&quot;/&gt;</code></a></td><td>onUnload</td><td>onLoad、onShow</td></tr><tr><td>页面返回</td><td>调用 API <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html#wxnavigateback" target="_blank" rel="noopener"><code>wx.navigateBack</code></a> 或使用组件<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html" target="_blank" rel="noopener"><code>&lt;navigator open-type=&quot;navigateBack&quot;&gt;</code></a>或用户按左上角返回按钮</td><td>onUnload</td><td>onShow</td></tr><tr><td>Tab 切换</td><td>调用 API <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html#wxswitchtab" target="_blank" rel="noopener"><code>wx.switchTab</code></a> 或使用组件 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html" target="_blank" rel="noopener"><code>&lt;navigator open-type=&quot;switchTab&quot;/&gt;</code></a> 或用户切换 Tab</td><td></td><td>具体情况参考下表</td></tr><tr><td>重启动</td><td>调用 API <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html#wxrelaunch" target="_blank" rel="noopener"><code>wx.reLaunch</code></a> 或使用组件 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html" target="_blank" rel="noopener"><code>&lt;navigator open-type=&quot;reLaunch&quot;/&gt;</code></a></td><td>onUnload</td><td>onLoad, onShow</td></tr></tbody></table><p>Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）</p><table><thead><tr><th>当前页面</th><th>路由后页面</th><th>触发的生命周期</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>无</td></tr><tr><td>A</td><td>B（首次打开）</td><td>A.onHide(), B.onLoad(), B.onShow()</td></tr><tr><td>A</td><td>B（再次打开）</td><td>A.onHide(), B.onShow()</td></tr><tr><td>C</td><td>A</td><td>C.onUnload(), A.onShow()</td></tr><tr><td>C</td><td>B（首次打开）</td><td>C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td>D</td><td>B</td><td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td>D（从转发进入）</td><td>A</td><td>D.onUnload(), A.onLoad(), A.onShow()</td></tr><tr><td>D（从转发进入）</td><td>B</td><td>D.onUnload(), B.onLoad(), B.onShow()</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页面路由&quot;&gt;&lt;a href=&quot;#页面路由&quot; class=&quot;headerlink&quot; title=&quot;页面路由&quot;&gt;&lt;/a&gt;页面路由&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;小程序中所有页面的路由全部由框架进行管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;页面
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序页面注册</title>
    <link href="https://hexuanzhang.github.io/2018/02/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E6%B3%A8%E5%86%8C/"/>
    <id>https://hexuanzhang.github.io/2018/02/07/小程序页面注册/</id>
    <published>2018-02-07T14:36:04.000Z</published>
    <updated>2018-02-07T14:40:10.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h2><blockquote><p>通过 <code>Page()</code> 函数注册页面，函数接受 <code>Object</code> 参数，指定页面的初始数据、生命周期函数、事件处理函数等</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>Object</td><td>初始化数据</td></tr><tr><td>onLoad</td><td>Function</td><td>生命周期函数–监听页面加载</td></tr><tr><td>onReady</td><td>Function</td><td>生命周期函数–监听页面初次渲染完成</td></tr><tr><td>onShow</td><td>Function</td><td>生命周期函数–监听页面显示</td></tr><tr><td>onHide</td><td>Function</td><td>生命周期函数–监听页面隐藏</td></tr><tr><td>onUnload</td><td>Function</td><td>生命周期函数–监听页面卸载</td></tr><tr><td>onPullDownRefresh</td><td>Function</td><td>页面相关事件处理函数–监听用户下拉动作</td></tr><tr><td>onReachBottom</td><td>Function</td><td>页面上拉触底事件的处理函数</td></tr><tr><td>onShareAppMessage</td><td>Function</td><td>右上角转发函数</td></tr><tr><td>onPageScroll</td><td>Function</td><td>页面滚动函数</td></tr><tr><td>onTabItemTap</td><td>Function</td><td>当前是 tab 页时，点击 tab 时触发</td></tr><tr><td>其他</td><td>Any</td><td>可以添加任意的函数或数据到 object 参数中，在页面的函数中用 <code>this</code> 可以访问</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        text: &quot;This is page data.&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLoad: (options) =&gt; &#123; &#125;,</span><br><span class="line">    onReady: () =&gt; &#123; &#125;,</span><br><span class="line">    onShow: () =&gt; &#123; &#125;,</span><br><span class="line">    onHide: () =&gt; &#123; &#125;,</span><br><span class="line">    onUnload: () =&gt; &#123; &#125;,</span><br><span class="line">    onPullDownRefresh: () =&gt; &#123; &#125;,</span><br><span class="line">    onReachBottom: () =&gt; &#123; &#125;,</span><br><span class="line">    onShareAppMessage: () =&gt; &#123; &#125;,</span><br><span class="line">    onPageScroll: () =&gt; &#123; &#125;,</span><br><span class="line">    onTabItemTap: (item) =&gt; &#123;</span><br><span class="line">        console.log(item.index)</span><br><span class="line">        console.log(item.pagePath)</span><br><span class="line">        console.log(item.text)</span><br><span class="line">    &#125;,</span><br><span class="line">    viewTap: function () &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            text: &apos;Set some data for updating view.&apos;</span><br><span class="line">        &#125;, function () &#123;</span><br><span class="line">            // this is setData callback</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    otherData: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><ul><li><p><code>onLoad</code></p><blockquote><p>只调用一次，可以在该函数中获取其他页面打开当前页面所调用的 <code>query</code> 参数</p></blockquote></li><li><p><code>onShow</code></p><blockquote><p>每次打开页面都会调用</p></blockquote></li><li><p><code>onReady</code></p><blockquote><p>页面初次渲染时调用，此时可以与视图进行交互</p><p>对界面进行设置如 <code>wx.setNavigationBarTitle</code> 需在该函数之后</p></blockquote></li><li><p><code>onHide</code></p><blockquote><p>使用 <code>navigateTo</code> 或切换底部 <code>tab</code> 时调用</p></blockquote></li><li><p><code>onUnload</code></p><blockquote><p>使用 <code>redirectTo</code> 或 <code>navigateBack</code> 时调用</p></blockquote></li></ul><p><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/mina-lifecycle.png?t=201822" alt="img"></p><h3 id="页面相关事件处理函数"><a href="#页面相关事件处理函数" class="headerlink" title="页面相关事件处理函数"></a>页面相关事件处理函数</h3><ul><li><p><code>onPullDownRefresh</code></p><blockquote><p>监听下拉刷新事件</p><p>需要在全局配置或页面配置中开启 <code>enablePullDownRefresh</code></p><p>当处理完数据刷新后，可以通过 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/pulldown.html#wxstoppulldownrefresh" target="_blank" rel="noopener"><code>wx.stopPullDownRefresh</code></a> 停止当前页面的下拉刷新，也可通过 <code>wx.startPullDownRefresh</code> 调触发下拉刷新动画</p></blockquote></li><li><p><code>onReachBottom</code></p><blockquote><p>监听上拉触底事件</p><p>需要在全局配置或页面配置中设置触发距离 <code>onReachBottomDistance</code></p><p>在触发距离内滑动期间只会被触发一次</p></blockquote></li><li><p><code>onPageScroll</code></p><blockquote><p>监听页面滚动事件</p><p>参数为 Object，包含 <code>scrollTop</code> 字段（页面在垂直方向已滚动的距离，单位px）</p></blockquote></li><li><p><code>onShareAppMessage</code></p><blockquote><p>只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮，点击转发按钮时触发</p><p>该事件需要返回一个 <code>Object</code>，用于自定义转发内容，包含转发标题和转发路径</p><blockquote><p>title：转发标题，默认为小程序名称</p><p>path：转发路径，必须以 / 开头，默认为当前页面路径</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    onShareAppMessage: () =&gt; (&#123;</span><br><span class="line">        title: &apos;自定义转发标题&apos;,</span><br><span class="line">        path: &apos;/pages/logs/logs&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Page-prototype-route"><a href="#Page-prototype-route" class="headerlink" title="Page.prototype.route"></a>Page.prototype.route</h3><blockquote><p><code>route</code> 字段可以获取到当前页面的路径</p><p>在 <code>onReay</code>、<code>onLoad</code>等函数中调用该字段会报错</p></blockquote><h3 id="Page-prototype-setData"><a href="#Page-prototype-setData" class="headerlink" title="Page.prototype.setData()"></a>Page.prototype.setData()</h3><blockquote><p><code>setData</code> 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 <code>this.data</code> 的值（同步）</p><p><strong>直接修改 this.data 而不调用 this.setData 是无法改变页面状态，还会造成数据不一致</strong></p><p><strong>单次修改的数据不能超过 1024kB，请尽量避免一次设置过多的数据</strong></p><p>不要把 data 中任何一项的 value 设为 <code>undefined</code> ，否则这一项将不被设置并可能遗留一些潜在问题</p></blockquote><table><thead><tr><th>字段</th><th>类型</th><th>必填</th><th>描述</th><th>最低版本</th></tr></thead><tbody><tr><td>data</td><td>Object</td><td>是</td><td>需要改变的数据（key: value）</td><td></td></tr><tr><td>callback</td><td>Function</td><td>否</td><td>回调函数</td><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/compatibility.html" target="_blank" rel="noopener">1.5.0</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注册页面&quot;&gt;&lt;a href=&quot;#注册页面&quot; class=&quot;headerlink&quot; title=&quot;注册页面&quot;&gt;&lt;/a&gt;注册页面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过 &lt;code&gt;Page()&lt;/code&gt; 函数注册页面，函数接受 &lt;code&gt;Object&lt;/
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序运行机制和注册</title>
    <link href="https://hexuanzhang.github.io/2018/02/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B3%A8%E5%86%8C/"/>
    <id>https://hexuanzhang.github.io/2018/02/06/小程序运行机制和注册/</id>
    <published>2018-02-06T14:51:33.000Z</published>
    <updated>2018-02-06T14:53:08.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><blockquote><p>小程序启动有两种情况，一种是「冷启动」，一种是「热启动」</p><p>热启动：用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台</p><p>冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动</p></blockquote><h3 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h3><blockquote><p>小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才能应用</p></blockquote><h3 id="运行机制-1"><a href="#运行机制-1" class="headerlink" title="运行机制"></a>运行机制</h3><blockquote><p>小程序没有重启的概念，当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁；另外，当短时间内（5s）连续收到两次以上收到系统内存告警也会销毁小程序</p></blockquote><h3 id="再次打开逻辑"><a href="#再次打开逻辑" class="headerlink" title="再次打开逻辑"></a>再次打开逻辑</h3><p>用户打开小程序的预期有以下两类场景:</p><ul><li>打开首页 A： <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/scene.html" target="_blank" rel="noopener">场景值</a>有 1001, 1019, 1022, 1023, 1038, 1056</li><li>打开小程序指定的某个页面 B： 场景值为除 A 以外的其他</li></ul><p>当再次打开一个小程序逻辑如下：</p><table><thead><tr><th>上一次场景</th><th>当前打开场景</th><th>效果</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>保留原状态</td></tr><tr><td>B</td><td>A</td><td>清空原来的页面栈，打开首页（相当于执行 wx.reLaunch 到首页）</td></tr><tr><td>A / B</td><td>B</td><td>清空原来的页面栈，打开指定页面（相当于执行 wx.reLaunch 到指定页）</td></tr></tbody></table><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><blockquote><p>通过 <code>app()</code> 函数来注册小程序，该函数接受 <code>Object</code> 对象，用于指定小程序的生命周期函数等</p><p><code>App()</code> 必须在 <code>app.js</code> 中注册，且不能注册多个</p><p>不要在定义于 <code>App()</code> 内的函数中调用 <code>getApp()</code> ，使用 <code>this</code> 就可以拿到 app 实例</p><p>不要在 <code>onLaunch</code> 的时候调用 <code>getCurrentPages()</code>，此时 page 还没有生成</p><p>通过 <code>getApp()</code> 获取实例之后，不要私自调用生命周期函数</p><p>由于 Android 系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值</p><p><strong>前台、后台定义：</strong>用户点击左上角关闭，或按 Home 键离开微信时，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台；只有当小程序进入后台一定时间（目前是 5 分钟），或者系统资源占用过高，才会被真正的销毁</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td>onLaunch</td><td>Function</td><td>小程序初始化</td><td>小程序初始化完成时触发（全局只触发一次）</td></tr><tr><td>onShow</td><td>Function</td><td>小程序显示</td><td>小程序启动或从后台进入前台显示时触发</td></tr><tr><td>onHide</td><td>Function</td><td>小程序隐藏</td><td>小程序从前台进入后台时触发</td></tr><tr><td>onError</td><td>Function</td><td>错误监听函数</td><td>小程序发生脚本错误或调用 api 失败时触发</td></tr><tr><td>其他</td><td>Any</td><td></td><td>可以添加任意函数或数据到 <code>Object</code> 中，并通过 <code>this</code> 访问</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    onLaunch: (options) =&gt; &#123;&#125;,</span><br><span class="line">    onShow: (options) =&gt; &#123;&#125;,</span><br><span class="line">    onHide: () =&gt; &#123;&#125;,</span><br><span class="line">    onError: (msg) =&gt; &#123;&#125;,</span><br><span class="line">    globalData: &apos;I am global data&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="onLaunch-onShow-参数"><a href="#onLaunch-onShow-参数" class="headerlink" title="onLaunch, onShow 参数"></a>onLaunch, onShow 参数</h3><blockquote><p>具体的场景值，<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/scene.html" target="_blank" rel="noopener">详见</a></p></blockquote><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>String</td><td>打开小程序路径</td></tr><tr><td>query</td><td>Object</td><td>打开小程序的查询参数</td></tr><tr><td>scene</td><td>Number</td><td>打开小程序的场景值</td></tr><tr><td>shareTicket</td><td>String</td><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/share.html#%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E8%BD%AC%E5%8F%91%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">shareTicket</a></td></tr><tr><td>referrerInfo</td><td>Object</td><td>当场景为由从另一个小程序或公众号或App打开时，返回此字段</td></tr><tr><td>referrerInfo.appId</td><td>String</td><td>来源小程序或公众号或 App 的 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html#onlaunch-onshow-%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">appId</a></td></tr><tr><td>referrerInfo.extraData</td><td>Object</td><td>来源小程序传过来的数据，scene=1037或1038时支持</td></tr></tbody></table><h3 id="getApp"><a href="#getApp" class="headerlink" title="getApp()"></a>getApp()</h3><blockquote><p>通过 <code>getApp()</code> 函数可以获取小程序实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const appInstance = getApp()</span><br><span class="line">console.log(appInstance.globalData);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;运行机制&quot;&gt;&lt;a href=&quot;#运行机制&quot; class=&quot;headerlink&quot; title=&quot;运行机制&quot;&gt;&lt;/a&gt;运行机制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;小程序启动有两种情况，一种是「冷启动」，一种是「热启动」&lt;/p&gt;
&lt;p&gt;热启动：用户已经打开过某小
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序样式</title>
    <link href="https://hexuanzhang.github.io/2018/02/01/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%B7%E5%BC%8F/"/>
    <id>https://hexuanzhang.github.io/2018/02/01/小程序样式/</id>
    <published>2018-02-01T13:53:42.000Z</published>
    <updated>2018-02-01T13:55:12.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h2><blockquote><p>小程序通过 <code>WXSS</code> 文件来控制页面样式，<code>WXSS</code> 具有 <code>CSS</code> 大部分特性并对其进行了扩充和修改，扩充的特性如下：</p></blockquote><h3 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h3><blockquote><p>增加了新单位 <code>rpx(responsive pixel)</code> ：可以根据屏幕宽度自适应，规定的屏幕宽度为 750rpx；如在 iPhone6 上，屏幕宽度为 375px 即 750 个物理像素，则 750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素</p></blockquote><table><thead><tr><th>设备</th><th>rpx 换算 px（屏幕宽度 / 750）</th><th>px 换算 rpx（750 / 屏幕宽度）</th></tr></thead><tbody><tr><td>iPhone 5</td><td>1rpx = 0.42px</td><td>1px = 2.34rpx</td></tr><tr><td>iPhone 6</td><td>1rpx = 0.5px</td><td>1px = 2rpx</td></tr><tr><td>iPhone 7</td><td>1rpx = 0.552px</td><td>1px = 1.81rpx</td></tr></tbody></table><h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><blockquote><p>通过 <code>@import</code> 导入外联样式表，必须是相对路径，以 <code>;</code> 号结束</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** common.wxss **/</span><br><span class="line">.small-p &#123;</span><br><span class="line">    padding: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** app.wxss **/</span><br><span class="line">@import &quot;common.wxss&quot;;</span><br><span class="line">.middle-p &#123;</span><br><span class="line">    padding: 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><blockquote><p>在页面中可以 <code>style</code> 或 <code>class</code> 控制页面元素样式</p><p>应尽量避免使用 <code>style</code> 内联样式，以免影响渲染速度</p><p><code>class</code> 名不允许包含 <code>.</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view style=&quot;color:&#123;&#123;color&#125;&#125;;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;view class=&quot;normal_view&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>目前支持的选择器有：</p><table><thead><tr><th>选择器</th><th>样例</th></tr></thead><tbody><tr><td>类选择器</td><td>.class</td></tr><tr><td>ID 选择器</td><td>‘#ID’</td></tr><tr><td>元素选择器</td><td>Element，Element Element</td></tr><tr><td>伪元素选择器</td><td>Element:before，Element:after</td></tr></tbody></table><h3 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h3><blockquote><p>定义在 <code>app.wxss</code> 中的样式为全局样式，作用于每个页面中；<code>Page</code> 中的 <code>wxss</code> 文件为局部样式，只作用于当前页面，并会覆盖全局样式</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WXSS-样式&quot;&gt;&lt;a href=&quot;#WXSS-样式&quot; class=&quot;headerlink&quot; title=&quot;WXSS 样式&quot;&gt;&lt;/a&gt;WXSS 样式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;小程序通过 &lt;code&gt;WXSS&lt;/code&gt; 文件来控制页面样式，&lt;co
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序 WXS 总结</title>
    <link href="https://hexuanzhang.github.io/2018/01/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F-WXS-%E6%80%BB%E7%BB%93/"/>
    <id>https://hexuanzhang.github.io/2018/01/31/小程序-WXS-总结/</id>
    <published>2018-01-31T14:22:35.000Z</published>
    <updated>2018-02-07T15:49:03.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序-WXS-总结"><a href="#小程序-WXS-总结" class="headerlink" title="小程序 WXS 总结"></a>小程序 WXS 总结</h2><h3 id="语法对比"><a href="#语法对比" class="headerlink" title="语法对比"></a>语法对比</h3><blockquote><p><code>wxs</code> 不支持 <code>ES6</code> 语法，其标准基本是参考 <code>ES5</code> 标准，在以下细节之处有些许出入：</p></blockquote><ul><li><p>变量名</p><blockquote><p><code>wxs</code> 中要求变量名只允许包含字母、数字、下划线，且不能以数字开头</p><p><code>ES5</code> 中变量名允许包含字母、数字、下划线、美元符，同样不能以数字开头</p></blockquote></li><li><p>注释</p><blockquote><p><code>wxs</code> 和 <code>ES5</code> 都支持单行注释及多行注释 ，另外，<code>wxs</code> 还支持结尾注释</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- wxml --&gt;</span><br><span class="line">&lt;wxs module=&quot;sample&quot;&gt;</span><br><span class="line">// 方法一：单行注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法二：多行注释</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法三：结尾注释。即从 /* 开始往后的所有 WXS 代码均被注释</span><br><span class="line"></span><br><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">var c = &quot;fake&quot;;</span><br><span class="line"></span><br><span class="line">&lt;/wxs&gt;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote><p><code>wxs</code> 代码可以写在 <code>&lt;wxs&gt;</code> 标签内，或以 <code>.wxs</code> 为后缀名的文件内</p><p>每个 <code>.wxs</code> 文件和 <code>&lt;wxs&gt;</code> 标签都是一个单独的模块，有自己独立的作用域；模块内的变量和函数对其他模块不可见，但可通过 <code>module.exports</code> 暴露内部数据</p></blockquote><h4 id="wxs-标签"><a href="#wxs-标签" class="headerlink" title="wxs 标签"></a>wxs 标签</h4><blockquote><p><code>wxs</code> 标签包含两个属性：<code>module</code> 和 <code>src</code> ；<code>module</code> 属性表示模块名，必填；<code>src</code> 属性表示引用的 <code>.wxs</code> 文件的相对路径，</p><p><code>module</code> 属性必填，表示模块名，其规则与变量命名规则一致，如果在同一 <code>wxml</code> 中存在同名，则后者覆盖前者</p><p><code>src</code> 属性表示引用的其它 <code>.wxs</code> 文件的相对路径，仅在 <code>wxs</code> 标签为单闭合标签或标签内容为空时有效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--wxml--&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs module=&quot;foo&quot;&gt;</span><br><span class="line">var msg = &quot;hello world&quot;;</span><br><span class="line">module.exports = &#123; msg: msg &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt; &#123;&#123;foo.msg&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure><h4 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h4><blockquote><p>每个 <code>wxs</code> 模块均有一个内置的 <code>module</code> 对象，该对象有个 <code>exports</code> 属性，可以对外共享模块内的私有变量和函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// /pages/tools.wxs</span><br><span class="line">var foo = &quot;&apos;hello world&apos; from tools.wxs&quot;;</span><br><span class="line"></span><br><span class="line">var bar = function (d) &#123;</span><br><span class="line">    return d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123; foo: foo, bar: bar &#125;;</span><br><span class="line">module.exports.msg = &quot;some msg&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=&quot;./../tools.wxs&quot; module=&quot;tools&quot; /&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.msg&#125;&#125; &lt;/view&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.bar(tools.foo)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure><h4 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h4><blockquote><p>若想在<code>.wxs</code> 模块中引用其他 <code>.wxs</code> 模块，可以通过 <code>require</code> 函数实现；<code>require</code> 函数还可以引用 <code>.js</code> 模块</p><p><strong>引用时需注意使用相对路径，不能使用绝对路径</strong></p><p><strong><code>wxs</code> 模块均为单例，在第一次被引用时会自动初始化为单例对象；多个页面，多个地方，多次引用，使用的都是同一个 <code>wxs</code>模块对象</strong></p><p><strong>如果 <code>wxs</code> 模块在定义后未被引用，则该模块不会被解析运行</strong></p><p><code>&lt;wxs&gt;</code> 模块只能在定义该模块的 <code>WXML</code> 文件访问，如果该 <code>WXML</code> 文件被其他 <code>WXML</code> 文件引用，则这个<code>&lt;wxs&gt;</code> 模块不会被引入到对应的 <code>WXML</code> 文件中；同理在 <code>&lt;template&gt;</code> 标签中只能使用其被定义所在<code>WXML</code> 文件中定义的 <code>&lt;wxs&gt;</code> 模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// /pages/logic.wxs</span><br><span class="line">var tools = require(&quot;./tools.wxs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(tools.fOO);</span><br><span class="line">console.log(tools.bar(&quot;logic.wxs&quot;));</span><br><span class="line">console.log(tools.msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- /page/index/index.wxml --&gt;</span><br><span class="line">&lt;wxs src=&quot;./../logic.wxs&quot; module=&quot;logic&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小程序-WXS-总结&quot;&gt;&lt;a href=&quot;#小程序-WXS-总结&quot; class=&quot;headerlink&quot; title=&quot;小程序 WXS 总结&quot;&gt;&lt;/a&gt;小程序 WXS 总结&lt;/h2&gt;&lt;h3 id=&quot;语法对比&quot;&gt;&lt;a href=&quot;#语法对比&quot; class=&quot;head
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序事件介绍</title>
    <link href="https://hexuanzhang.github.io/2018/01/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%8B%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://hexuanzhang.github.io/2018/01/30/小程序事件介绍/</id>
    <published>2018-01-30T15:33:55.000Z</published>
    <updated>2018-01-30T15:36:19.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h4 id="冒泡事件"><a href="#冒泡事件" class="headerlink" title="冒泡事件"></a>冒泡事件</h4><blockquote><p><code>&lt;canvas/&gt;</code>  的触摸事件不可冒泡</p></blockquote><table><thead><tr><th>类型</th><th>触发条件</th><th>最低版本</th></tr></thead><tbody><tr><td>touchstart</td><td>手指触摸动作开始</td><td></td></tr><tr><td>touchmove</td><td>手指触摸后移动</td><td></td></tr><tr><td>touchcancel</td><td>手指触摸动作被打断，如来电提醒，弹窗</td><td></td></tr><tr><td>touchend</td><td>手指触摸动作结束</td><td></td></tr><tr><td>tap</td><td>手指触摸后马上离开</td><td></td></tr><tr><td>longpress</td><td>手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/compatibility.html" target="_blank" rel="noopener">1.5.0</a></td></tr><tr><td>longtap</td><td>手指触摸后，超过 350ms 再离开（推荐使用longpress事件代替）</td><td></td></tr><tr><td>transitionend</td><td>在 <code>WXSS transition</code> 或 <code>wx.createAnimation</code> 动画结束后触发</td><td></td></tr><tr><td>animationstart</td><td>在 <code>WXSS animation</code> 动画开始时触发</td><td></td></tr><tr><td>animationiteration</td><td>在 <code>WXSS animation</code> 一次周期结束时触发</td><td></td></tr><tr><td>animationend</td><td>在 <code>WXSS animation</code> 动画完成时触发</td></tr></tbody></table><p><strong>除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 <code>&lt;form/&gt;</code> 的<code>submit</code> 事件，<code>&lt;input/&gt;</code> 的 <code>input</code> 事件，<code>&lt;scroll-view/&gt;</code> 的 <code>scroll</code> 事件，(详见各个<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/" target="_blank" rel="noopener">组件</a>)</strong></p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="冒泡事件绑定"><a href="#冒泡事件绑定" class="headerlink" title="冒泡事件绑定"></a>冒泡事件绑定</h4><blockquote><p>通过 <code>key=value</code> 的形式绑定事件，<code>key</code> 可以是 <code>bind</code> 或 <code>catch</code> 开头，再加上事件类型，如 <code>bindtap</code> 、<code>catchtouchstart</code> 等；<code>value</code> 对应 Page 中定义的函数名</p><p>从基础库 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/compatibility.html" target="_blank" rel="noopener">1.5.0</a> 开始，允许使用 <code>key:value</code> 的形式绑定事件</p><p><code>bind</code> 和 <code>catch</code> 的区别在于：<code>bind</code> 无法阻止事件冒泡，<code>catch</code> 可以阻止冒泡事件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 点击 inner view 会先后调用 tapInner 和 tapMiddle</span><br><span class="line">// 点击 middle view 只会调用 tapMiddle</span><br><span class="line"></span><br><span class="line">&lt;view id=&quot;outer&quot; bindtap=&quot;tapOut&quot;&gt;</span><br><span class="line">    outer view</span><br><span class="line">    &lt;view id=&quot;middle&quot; catchtap=&quot;tapMiddle&quot;&gt;</span><br><span class="line">        middle view</span><br><span class="line">        &lt;view id=&quot;inner&quot; bindtap=&quot;tapInner&quot;&gt;</span><br><span class="line">            inner view</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180130/ILahFd5Fcj.png?imageslim" alt="mark"></p><h4 id="捕获事件绑定"><a href="#捕获事件绑定" class="headerlink" title="捕获事件绑定"></a>捕获事件绑定</h4><blockquote><p>自基础库 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/compatibility.html" target="_blank" rel="noopener">1.5.0</a> 起，支持绑定触摸类型捕获事件；绑定的方式与冒泡事件略有差别，捕获事件的绑定是通过 <code>capture-bind</code>、<code>capture-catch</code>关键字实现</p><p><code>capture-catch</code> 能中断捕获阶段和取消冒泡阶段</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 点击 inner view 先后调用 touchOutCapture、touchInnerCapture、touchInner、touchOut</span><br><span class="line">&lt;view id=&quot;outer&quot; bind:touchstart=&quot;touchOut&quot; capture-bind:touchstart=&quot;touchOutCapture&quot;&gt;</span><br><span class="line">    outer view</span><br><span class="line">    &lt;view id=&quot;inner&quot; bind:touchstart=&quot;touchInner&quot; capture-bind:touchstart=&quot;touchInnerCapture&quot;&gt;</span><br><span class="line">        inner view</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 点击 inner view 只会调用 touchOutCapture</span><br><span class="line">&lt;view id=&quot;outer&quot; bind:touchstart=&quot;touchOut&quot; capture-catch:touchstart=&quot;touchOutCapture&quot;&gt;</span><br><span class="line">    outer view</span><br><span class="line">    &lt;view id=&quot;inner&quot; bind:touchstart=&quot;touchInner&quot; capture-catch:touchstart=&quot;touchInnerCapture&quot;&gt;</span><br><span class="line">        inner view</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180130/begmLBckHl.png?imageslim" alt="mark"></p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><blockquote><p>当触发事件时，会给事件处理函数传递一个事件对象，事件对象具体包含内容如下：</p><p><strong>由于 <code>&lt;canvas/&gt;</code> 的触摸事件不可冒泡，因此 <code>&lt;canvas/&gt;</code> 的触摸事件对象没有 <code>currentTarget</code> 属性</strong></p></blockquote><p><strong>BaseEvent 基础事件对象属性列表：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>String</td><td>事件类型</td></tr><tr><td>timestamp</td><td>Number</td><td>事件触发时的时间戳</td></tr><tr><td>target</td><td>Object</td><td>触发事件的组件的一些属性集合</td></tr><tr><td>currentTarget</td><td>Object</td><td>事件的当前目标组件的一些属性集合</td></tr></tbody></table><p><strong>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>detail</td><td>Object</td><td>额外的信息</td></tr></tbody></table><p><strong>TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>touches</td><td>Array</td><td>触摸事件，当前停留在屏幕中的触摸点信息的数组</td></tr><tr><td>changedTouches</td><td>Array</td><td>触摸事件，当前变化的触摸点信息的数组</td></tr></tbody></table><h4 id="target-currentTarget"><a href="#target-currentTarget" class="headerlink" title="target / currentTarget"></a>target / currentTarget</h4><blockquote><p>元素自定义属性以 <code>data-</code> 开头，多个单词由连字符 <code>-</code> 链接，不能有大写(大写会自动转成小写)如 <code>data-element-type</code>，最终在 <code>event.currentTarget.dataset</code> 中会将连字符转成驼峰 <code>elementType</code></p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>元素或组件 ID</td></tr><tr><td>tagName</td><td>String</td><td>元素或组件类型</td></tr><tr><td>dataset</td><td>Object</td><td>元素或组件上自定义属性（<code>data-</code>）集合</td></tr></tbody></table><h4 id="touches"><a href="#touches" class="headerlink" title="touches"></a>touches</h4><blockquote><p><code>touches</code> 是一个数组，每个元素为一个 <code>Touch</code> 对象（ <code>canvas</code> 触摸事件中携带的 <code>touches</code> 是 <code>CanvasTouch</code> 数组）， 表示当前停留在屏幕上的触摸点</p></blockquote><p><strong>Touch 对象</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>identifier</td><td>Number</td><td>触摸点的标识符</td></tr><tr><td>pageX, pageY</td><td>Number</td><td>距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴</td></tr><tr><td>clientX, clientY</td><td>Number</td><td>距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴</td></tr></tbody></table><p><strong>CanvasTouch 对象</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>identifier</td><td>String</td><td>触摸点的标识符</td></tr><tr><td>x，y</td><td>Number</td><td>距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴</td></tr></tbody></table><h4 id="changedTouches"><a href="#changedTouches" class="headerlink" title="changedTouches"></a>changedTouches</h4><blockquote><p><code>changedTouches</code> 数据格式同 <code>touches</code>， 表示有变化的触摸点，如从无变有（<code>touchstart</code>），位置变化（<code>touchmove</code>），从有变无（<code>touchend</code>、<code>touchcancel</code>）</p></blockquote><h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4><blockquote><p>自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/wxml/wxml-component.md" target="_blank" rel="noopener">组件</a> 定义中各个事件的定义。</p><p>点击事件中的 <code>detail</code> 带有的 <code>x</code>, <code>y</code> 同 <code>pageX</code>, <code>pageY</code> 代表距离文档左上角的距离。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h2&gt;&lt;h3 id=&quot;事件类型&quot;&gt;&lt;a href=&quot;#事件类型&quot; class=&quot;headerlink&quot; title=&quot;事件类型&quot;&gt;&lt;/a&gt;事件类型&lt;/h
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序页面模板</title>
    <link href="https://hexuanzhang.github.io/2018/01/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"/>
    <id>https://hexuanzhang.github.io/2018/01/30/小程序页面模板/</id>
    <published>2018-01-30T15:27:28.000Z</published>
    <updated>2018-01-30T15:27:50.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><blockquote><p>可以定义不同类型的模板，以便在不同地方调用</p></blockquote><h3 id="定义模版"><a href="#定义模版" class="headerlink" title="定义模版"></a>定义模版</h3><blockquote><p>在 <code>&lt;template /&gt;</code> 中定义模板内容，并通过 <code>name</code> 属性指定模板名称</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;itemTpl&quot;&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;text&gt;&#123;&#123;index&#125;&#125; : &#123;&#123;message&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="模板使用"><a href="#模板使用" class="headerlink" title="模板使用"></a>模板使用</h3><blockquote><p>使用 <code>is</code> 属性声明需要使用的模板，模板所需数据通过 <code>data</code> 属性传递</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=&quot;itemTpl&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        item: &#123;</span><br><span class="line">            index: 0,</span><br><span class="line">            msg: &apos;this is a template&apos;,</span><br><span class="line">            time: &apos;2016-09-15&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;odd&quot;&gt;</span><br><span class="line">    &lt;view&gt;odd&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template name=&quot;even&quot;&gt;</span><br><span class="line">    &lt;view&gt;even&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;block wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;template is=&quot;&#123;&#123;item % 2 == 0 ? &apos;even&apos; : &apos;odd&apos;&#125;&#125;&quot; /&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><blockquote><p>有两种文件引用模板的方式，一种是 <code>import</code>， 另一种是<code>include</code></p></blockquote><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><blockquote><p>可以 <code>import</code> 目标文件到当前文件中，当前文件可以使用目标文件中的 <code>template</code></p><p><code>import</code> 的文件存在作用域，即只能使用 <code>import</code> 目标文件自己定义的 <code>template</code>，而无法使用 <code>import</code> 目标文件中 <code>import</code> 的 <code>template</code>，如：<code>C import B</code>，<code>B import A</code>，在 C 中可以使用 B 定义的 <code>template</code>，在 B 中可以使用 A 定义的 <code>template</code>，但是 C 不能使用 A 定义的 <code>template</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- item.wxml --&gt;</span><br><span class="line">&lt;template name=&quot;item&quot;&gt;</span><br><span class="line">    &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- index.wxml --&gt;</span><br><span class="line">&lt;import src=&quot;item.wxml&quot; /&gt;</span><br><span class="line">&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.wxml --&gt;</span><br><span class="line">&lt;template name=&quot;A&quot;&gt;</span><br><span class="line">    &lt;text&gt; A template &lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- B.wxml --&gt;</span><br><span class="line">&lt;import src=&quot;a.wxml&quot; /&gt;</span><br><span class="line">&lt;template name=&quot;B&quot;&gt;</span><br><span class="line">    &lt;text&gt; B template &lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- C.wxml --&gt;</span><br><span class="line">&lt;import src=&quot;b.wxml&quot; /&gt;</span><br><span class="line">&lt;template is=&quot;A&quot; /&gt; &lt;!-- Error! Can not use tempalte when not import A. --&gt;</span><br><span class="line">&lt;template is=&quot;B&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><blockquote><p><code>include</code> 是将目标文件中除了 <code>&lt;template/&gt;</code> 和 <code>&lt;wxs/&gt;</code> 之外的整个代码引入，相当于是拷贝到 <code>include</code> 位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- header.wxml --&gt;</span><br><span class="line">&lt;view&gt; header &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- footer.wxml --&gt;</span><br><span class="line">&lt;view&gt; footer &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- index.wxml --&gt;</span><br><span class="line">&lt;include src=&quot;header.wxml&quot; /&gt;</span><br><span class="line">&lt;view&gt; body &lt;/view&gt;</span><br><span class="line">&lt;include src=&quot;footer.wxml&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可以定义不同类型的模板，以便在不同地方调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定义模版&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>hexo 解析{{和}}报错</title>
    <link href="https://hexuanzhang.github.io/2018/01/25/hexo-%E8%A7%A3%E6%9E%90-%E5%92%8C-%E6%8A%A5%E9%94%99/"/>
    <id>https://hexuanzhang.github.io/2018/01/25/hexo-解析-和-报错/</id>
    <published>2018-01-25T15:08:31.000Z</published>
    <updated>2018-01-30T15:28:31.098Z</updated>
    
    <content type="html"><![CDATA[<p>晚上在更新文章时，使用 <code>hexo g</code> 生成报解析错误，具体错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: (unknown path) [Line 9, Column 14]</span><br><span class="line">unexpected token: &#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180125/LGJE7d936A.png?imageslim" alt="mark"></p><p>根据提示到 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting.html</a> 中找到了对应的解决方案：通过 <code>raw</code> 标签来包裹 <code> {{}}</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125; &#123;&#123; normal &#125;&#125; &#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>之后网上查具体资料，发现其他人还有种解决方案：在 <code> }}</code> 中间添加空格。但这种方法可能会有歧义，还是按照官方的解决方案来。</p><p>虽然这只是个小问题，还是记录下。希望 <code>hexo</code> 后续版本能修复下，毕竟如果文章中 <code> }}</code> 之类出现比较频繁，这种解决方案也有点麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;晚上在更新文章时，使用 &lt;code&gt;hexo g&lt;/code&gt; 生成报解析错误，具体错误如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="hexo" scheme="https://hexuanzhang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hexuanzhang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>小程序数据绑定和渲染</title>
    <link href="https://hexuanzhang.github.io/2018/01/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E6%B8%B2%E6%9F%93/"/>
    <id>https://hexuanzhang.github.io/2018/01/25/小程序数据绑定和渲染/</id>
    <published>2018-01-25T14:44:58.000Z</published>
    <updated>2018-01-25T15:34:04.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><blockquote><p>页面中所有绑定的数据都来自对应 <code>Page</code> 的 <code>data</code></p></blockquote><h3 id="简单绑定"><a href="#简单绑定" class="headerlink" title="简单绑定"></a>简单绑定</h3><blockquote><p>通过 <code>Mustache 语法（双大括号）</code> 包裹变量的方式进行数据绑定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &apos;Hello MINA!&apos;,</span><br><span class="line">        id: &apos;0&apos;,</span><br><span class="line">        flag: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;view&gt;&#123;&#123; message &#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:if=&quot;&#123;&#123; flag &#125;&#125;&quot;&gt;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;checkbox checked=&quot;&#123;&#123;flag&#125;&#125;&quot;&gt; &lt;/checkbox&gt;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><blockquote><p>可以在双大括号内进行简单的运算</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        flag: true,</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        text: &apos;world&apos;,</span><br><span class="line">        date: [new Date().toLocaleDateString()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;view hidden=&quot;&#123;&#123;flag ? true : false&#125;&#125;&quot;&gt;Hidden&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;&#123;&#123; a + b &#125;&#125; + c&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:if=&quot;&#123;&#123;a &gt; 5&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;&#123;&#123; &quot;hello&quot; + text &#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;text&gt;&#123;&#123;&quot;hello&quot; + text + &apos; &apos; +  date[0]&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>可以在 <code>{{}}</code>  内直接进行组合，构成新的对象或者数组</p><p><strong>花括号和引号之间如果有空格，将最终被解析成为字符串</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        zero: 0,</span><br><span class="line">        a: &apos;a&apos;,</span><br><span class="line">        b: &apos;b&apos;,</span><br><span class="line">        first: &#123;</span><br><span class="line">            a: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        second: &#123;</span><br><span class="line">            b: 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// [0, 1, 2, 3, 4, 5]</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;[zero, 1, 2, 3, 4, 5]&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// &#123;foo: &apos;a&apos;, bar: &apos;b&apos;&#125;</span><br><span class="line">&lt;template data=&quot;&#123;&#123;foo: a, bar: b&#125;&#125;&quot;&gt;&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// &#123;a: 1, b: 2, c: 3&#125;</span><br><span class="line">&lt;template data=&quot;&#123;&#123;...first, ...second, c: 3&#125;&#125;&quot;&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h4><blockquote><p>在组件（如 <code>view</code> ）或结构块（<code>block</code>，包装元素，只接受控制属性）中通过 <code>ws:for</code> 指令渲染数组中的数据项</p><p>数组当前项的变量名默认为<code>item</code>， 下标变量名默认为 <code>index</code></p><p><code>wx:for</code> 的值为字符串时，会将字符串解析成字符串数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [</span><br><span class="line">            &#123;</span><br><span class="line">                alias: &apos;first&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                alias: &apos;second&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                alias: &apos;third&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;&#123;&#123;index&#125;&#125; : &#123;&#123;item.alias&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemNmae&quot;&gt;&#123;&#123;idx&#125;&#125; : &#123;&#123;itemNmae.alias&#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;block wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view&gt; &#123;&#123;index&#125;&#125;: &lt;/view&gt;</span><br><span class="line">    &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><h4 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h4><blockquote><p>如果列表会发生变动（新增、删除等），且需保持列表项状态（如：<code>&lt;input/&gt;</code> 的内容、<code>&lt;switch/&gt;</code> 的选中状态等），则需要使用 <code>wx:key</code> 来指定列表中数据项的唯一的标识符</p><p><code>wx:key</code> 的值有两种形式：第一种是 <code>item</code> 中不会变动的某个 <code>property</code> 的值（字符串或数字），第二种是保留关键字 <code>*this</code>（代表 <code>item</code> 本身，并且是唯一的字符串或者数字）</p><p>当数据改变触发渲染层重新渲染的时候，会校正带有 <code>key</code> 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        objectArray: [</span><br><span class="line">            &#123; id: 5, unique: &apos;unique_5&apos; &#125;,</span><br><span class="line">            &#123; id: 4, unique: &apos;unique_4&apos; &#125;,</span><br><span class="line">            &#123; id: 3, unique: &apos;unique_3&apos; &#125;,</span><br><span class="line">            &#123; id: 2, unique: &apos;unique_2&apos; &#125;,</span><br><span class="line">            &#123; id: 1, unique: &apos;unique_1&apos; &#125;,</span><br><span class="line">            &#123; id: 0, unique: &apos;unique_0&apos; &#125;,</span><br><span class="line">        ],</span><br><span class="line">        numberArray: [1, 2, 3, 4]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;switch wx:for=&quot;&#123;&#123;objectArray&#125;&#125;&quot; wx:key=&quot;unique&quot; style=&quot;display: block;&quot;&gt; &#123;&#123;item.id&#125;&#125; &lt;/switch&gt;</span><br><span class="line"></span><br><span class="line">&lt;switch wx:for=&quot;&#123;&#123;numberArray&#125;&#125;&quot; wx:key=&quot;*this&quot; style=&quot;display: block;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/switch&gt;</span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="wx-if"><a href="#wx-if" class="headerlink" title="wx:if"></a>wx:if</h4><blockquote><p>通过 <code>wx:if=&quot;{{condition}}&quot;</code> 指令来判断是否需要渲染该代码块，可以作用于组件（如 <code>view</code> ）或结构块（<code>block</code> ）</p><p>可以用 <code>wx:elif</code> 或 <code>wx:else</code> 来添加一个 <code>else</code> 块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; True &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt;1&lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt;2&lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt;3&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view&gt; view1 &lt;/view&gt;</span><br><span class="line">    &lt;view&gt; view2 &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><h3 id="wx-if-vs-hidden"><a href="#wx-if-vs-hidden" class="headerlink" title="wx:if vs hidden"></a>wx:if vs hidden</h3><blockquote><p><code>wx:if</code>：变量值发生变动时，会进行局部渲染（销毁或渲染）</p><p><code>hidden</code>：组件始终会渲染，只是控制显示隐藏</p><p><code>hidden</code> 适合频繁切换的场景，<code>wx:if</code> 适合条件不经常变动的场景</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;Show&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;view hidden=&apos;&#123;&#123;!Show&#125;&#125;&apos;&gt;&lt;/view&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据绑定&quot;&gt;&lt;a href=&quot;#数据绑定&quot; class=&quot;headerlink&quot; title=&quot;数据绑定&quot;&gt;&lt;/a&gt;数据绑定&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;页面中所有绑定的数据都来自对应 &lt;code&gt;Page&lt;/code&gt; 的 &lt;code&gt;data&lt;/c
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>小程序配置解析</title>
    <link href="https://hexuanzhang.github.io/2018/01/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://hexuanzhang.github.io/2018/01/23/小程序配置解析/</id>
    <published>2018-01-23T15:15:56.000Z</published>
    <updated>2018-01-23T15:33:17.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><blockquote><p>通过 <code>app.json</code> 文件来配置一些全局属性，如页面文件路径、窗口变现、网络超时等</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;pages&quot;: [</span><br><span class="line">        &quot;pages/index/index&quot;,</span><br><span class="line">        &quot;pages/logs/logs&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;window&quot;: &#123;</span><br><span class="line">        &quot;backgroundTextStyle&quot;: &quot;light&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">        &quot;navigationBarTitleText&quot;: &quot;Demo&quot;,</span><br><span class="line">        &quot;navigationBarTextStyle&quot;: &quot;black&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tabBar&quot;: &#123;</span><br><span class="line">        &quot;list&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">                &quot;text&quot;: &quot;首页&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,</span><br><span class="line">                &quot;text&quot;: &quot;日志&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;networkTimeout&quot;: &#123;</span><br><span class="line">        &quot;request&quot;: 10000,</span><br><span class="line">        &quot;downloadFile&quot;: 10000</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><blockquote><p>必填，接受字符串数组格式</p><p>用于指定小程序包含的页面，每个页面的格式为 <code>路径 + 文件名</code>；文件名不需要带后缀，框架会自动寻找路径下 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行整合</p><p>数组的第一项为初始页，新增或减少页面都要修改该数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;pages&quot;: [</span><br><span class="line">    &quot;pages/index/index&quot;,</span><br><span class="line">    &quot;pages/logs/logs&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><blockquote><p>设置状态栏、导航、标题、窗口背景色</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#000000</td><td>导航栏背景颜色</td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜色，仅支持 black/white</td></tr><tr><td>navigationBarTitleText</td><td>String</td><td></td><td>导航栏标题文字内容</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>#ffffff</td><td>窗口背景色</td></tr><tr><td>backgroundTextStyle</td><td>String</td><td>dark</td><td>下拉背景字体、loading 图的样式，仅支持 dark/light</td></tr><tr><td>enablePullDownRefresh</td><td>Boolean</td><td>false</td><td>是否开启下拉刷新，详见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">页面相关事件处理函数</a></td></tr><tr><td>onReachBottomDistance</td><td>Number</td><td>50</td><td>页面上拉触底事件触发时距页面底部距离，单位为 px</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window: &#123;</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,</span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,</span><br><span class="line">    &quot;backgroundTextStyle&quot;: &quot;light&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/config.jpg?t=2018119" alt=""></p><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><blockquote><p>如果小程序是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面</p><p>position 为 top 时不会显示 icon</p><p>list 是一个数组，<strong>最少配置2个、最多5个 tab</strong>，tab 按数组的顺序排序</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>HexColor</td><td>是</td><td></td><td>tab 上文字默认颜色</td></tr><tr><td>selectedColor</td><td>HexColor</td><td>是</td><td></td><td>tab 上文字选中时的颜色</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>是</td><td></td><td>tab 背景色</td></tr><tr><td>list</td><td>Array</td><td>是</td><td></td><td>tab 列表，详见 list 属性说明，最少2个、最多5个</td></tr><tr><td>borderStyle</td><td>String</td><td>否</td><td>black</td><td>tabbar上边框颜色， 仅支持 black/white</td></tr><tr><td>position</td><td>String</td><td>否</td><td>bottom</td><td>可选值 bottom、top</td></tr></tbody></table><p>list 接受对象数组，对象属性值如下：</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>pagePath</td><td>String</td><td>是</td><td>页面路径，必须在 pages 中先定义</td></tr><tr><td>text</td><td>String</td><td>是</td><td>tab 上按钮文字</td></tr><tr><td>iconPath</td><td>String</td><td>否</td><td>图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片</td></tr><tr><td>selectedIconPath</td><td>String</td><td>否</td><td>选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效</td></tr></tbody></table><p><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/tabbar.png?t=2018119" alt=""></p><h3 id="networkTimeout"><a href="#networkTimeout" class="headerlink" title="networkTimeout"></a>networkTimeout</h3><blockquote><p>设置各种请求的超时时间，如上传下载、HTTP、Socket等</p><p>单位为毫秒</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>request</td><td>Number</td><td>否</td><td><code>wx.request</code> 的超时时间，默认为：60000</td></tr><tr><td>connectSocket</td><td>Number</td><td>否</td><td><code>wx.connectSocket</code> 的超时时间，默认为：60000</td></tr><tr><td>uploadFile</td><td>Number</td><td>否</td><td><code>wx.uploadFile</code> 的超时时间，默认为：60000</td></tr><tr><td>downloadFile</td><td>Number</td><td>否</td><td><code>wx.downloadFile</code> 的超时时间，默认为：60000</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">networkTimeout: &#123;</span><br><span class="line">    request: 6000,</span><br><span class="line">    connectSocket: 6000,</span><br><span class="line">    uploadFile: 6000,</span><br><span class="line">    downloadFile: 6000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><blockquote><p>默认为 <code>false</code>， 在开发者工具中开启 <code>debug</code> 模式</p><p>在控制台面板中以 info 的形式输出如 <code>Page 注册</code>、<code>路由跳转</code>、<code>数据更新</code> 等调试信息</p></blockquote><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/180122/2Fh0bD3jI0.png?imageslim" alt="mark">    </p><h2 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h2><blockquote><p>通过 <code>project.config.json</code> 文件来进行个性化配置，如设置界面颜色、编译条件等</p><p>开发工具会在每个项目根目录中生成这样一个配置文件</p></blockquote><table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>miniprogramRoot</td><td>Path String</td><td>指定小程序源码的目录(需为相对路径)</td></tr><tr><td>qcloudRoot</td><td>Path String</td><td>指定腾讯云项目的目录(需为相对路径)</td></tr><tr><td>setting</td><td>Object</td><td>项目设置</td></tr></tbody></table><p>setting 字段中可以设置如下属性：</p><table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>es6</td><td>Boolean</td><td>是否启用 es5 转 es6</td></tr><tr><td>postcss</td><td>Boolean</td><td>上传代码时样式是否自动补全</td></tr><tr><td>minified</td><td>Boolean</td><td>上传代码时是否自动压缩</td></tr><tr><td>urlCheck</td><td>Boolean</td><td>是否检查安全域名和 TLS 版本</td></tr><tr><td>newFeature</td><td>Boolean</td><td>是否支持新特性</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;miniprogramRoot&quot;: &quot;./src&quot;,</span><br><span class="line">    &quot;qcloudRoot&quot;: &quot;./svr&quot;,</span><br><span class="line">    &quot;setting&quot;: &#123;</span><br><span class="line">        &quot;postcss&quot;: true,</span><br><span class="line">        &quot;es6&quot;: true,</span><br><span class="line">        &quot;minified&quot;: true,</span><br><span class="line">        &quot;urlCheck&quot;: true,</span><br><span class="line">        &quot;newFeature&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h2><blockquote><p>每一个小程序页面也可以单独使用 <code>.json</code> 文件来对本页面的窗口表现进行配置</p><p>页面的 <code>.json</code> 只能设置 <code>window</code> 相关的配置项，会覆盖 <code>app.json</code> 的 <code>window</code> 中相同的配置项</p><p><code>disableScroll</code> 属性只对单独页面有效</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#000000</td><td>导航栏背景颜色</td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜色，仅支持 black/white</td></tr><tr><td>navigationBarTitleText</td><td>String</td><td></td><td>导航栏标题文字内容</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>#ffffff</td><td>窗口背景色</td></tr><tr><td>backgroundTextStyle</td><td>String</td><td>dark</td><td>下拉背景字体、loading 图的样式，仅支持 dark/light</td></tr><tr><td>enablePullDownRefresh</td><td>Boolean</td><td>false</td><td>是否开启下拉刷新，详见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">页面相关事件处理函数</a></td></tr><tr><td>onReachBottomDistance</td><td>Number</td><td>50</td><td>页面上拉触底事件触发时距页面底部距离，单位为 px</td></tr><tr><td>disableScroll</td><td>Boolean</td><td>false</td><td>设置为 true 则页面整体不能上下滚动</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局配置&quot;&gt;&lt;a href=&quot;#全局配置&quot; class=&quot;headerlink&quot; title=&quot;全局配置&quot;&gt;&lt;/a&gt;全局配置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过 &lt;code&gt;app.json&lt;/code&gt; 文件来配置一些全局属性，如页面文件路径、窗口变现
      
    
    </summary>
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/categories/wxLite/"/>
    
    
      <category term="wxLite" scheme="https://hexuanzhang.github.io/tags/wxLite/"/>
    
  </entry>
  
  <entry>
    <title>String 编码和解码</title>
    <link href="https://hexuanzhang.github.io/2017/12/28/String-%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"/>
    <id>https://hexuanzhang.github.io/2017/12/28/String-编码和解码/</id>
    <published>2017-12-27T16:16:10.000Z</published>
    <updated>2017-12-27T16:56:17.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TextEncoder"><a href="#TextEncoder" class="headerlink" title="TextEncoder"></a>TextEncoder</h2><ul><li><p>构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const encoder = new TextEncoder();</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-27-080800.png" alt=""></p><blockquote><p>  根据指定的编码格式生成 <code>encoder</code> 实例</p><p>  <code>Firefox 48</code> 和 <code>Chrome 53</code> 之后的版本为了与 <a href="https://www.w3.org/TR/encoding/#dom-textencoder" target="_blank" rel="noopener">规范</a> 保持一致，构造函数不需要传递参数，默认的编码格式为 <code>UTF-8</code>，即使传了其他的编码格式，也会调整为 <code>UTF-8</code>；可以通过 <a href="https://github.com/inexorabletash/text-encoding" target="_blank" rel="noopener">polyfill</a> 库，补充不支持的编码格式</p></blockquote></li><li><p>encoding</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new TextEncoder().encoding; // &apos;utf-8&apos;</span><br></pre></td></tr></table></figure><blockquote><p>  只读属性，返回指定的编码格式</p></blockquote></li><li><p>encode()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new TextEncoder() . encode([input = &quot;&quot;])</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-27-080919.png" alt=""></p><blockquote><p>  返回编码后的字符对象（<code>Unit8Array</code> 格式）</p></blockquote></li></ul><h2 id="TextDecoder"><a href="#TextDecoder" class="headerlink" title="TextDecoder"></a>TextDecoder</h2><ul><li><p>构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decoder = new TextDecoder([label = &quot;utf-8&quot; [, options]])</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-27-090851.png" alt=""></p><blockquote><p>  根据指定的解码格式生成 <code>decoder</code> 实例</p><p>  如果提供未知或模棱两可的解码格式 ，会报 <code>RangeError</code></p><p>  options：包含 <code>fatal</code> 、<code>ignoreBOM</code> 属性的 <code>TextDecoderOptions</code> 对象</p><blockquote><p>  fatal：布尔值，指明在解码过程中发生的错误是否需要抛出，默认为 false</p><p>  ignoreBOM：布尔值，是否忽略字节顺序标记（Byte Order Mark）</p></blockquote></blockquote></li><li><p>fatal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new TextDecoder().fatal;</span><br></pre></td></tr></table></figure><blockquote><p>  只读属性，指明在解码过程中发生的错误是否需要抛出</p></blockquote></li><li><p>ignoreBOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new TextDecoder().ignoreBOM;</span><br></pre></td></tr></table></figure><blockquote><p>  只读属性，是否忽略字节顺序标记</p></blockquote></li><li><p>decode()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new TextDecoder().decode([input [, options]]);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-27-093450.png" alt=""></p><blockquote><p>  根据指定的解码方式对编码数据进行解码，并返回解码后的字符串数据</p><p>  input：需要解码的数据（<code>ArrayBuffer</code> 格式或 <code>ArrayBufferView</code> 格式）</p><p>  options：包含 <code>stream</code> 属性的 <code>TextDecodeOptions</code> 对象</p><blockquote><p>  stream：布尔值，是否需要解码额外的数据</p></blockquote></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const text = &apos;hello word&apos;;</span><br><span class="line"></span><br><span class="line">const encode_text = new TextEncoder().encode(text);</span><br><span class="line"></span><br><span class="line">const decode_text = new TextDecoder(&apos;utf-8&apos;, &#123;fatal: true&#125;).decode(encode_text);</span><br><span class="line"></span><br><span class="line">console.info(Object.is(text, decode_text)); // true</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><table><thead><tr><th>浏览器</th><th>支持情况</th></tr></thead><tbody><tr><td>IE8 ~ IE11</td><td>不支持</td></tr><tr><td>Edge</td><td>暂不支持，在 <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/encodingstandard/" target="_blank" rel="noopener">开发阶段</a></td></tr><tr><td>Chrome</td><td>支持</td></tr><tr><td>Firefox</td><td>支持</td></tr><tr><td>Safari</td><td>10.1+ 版本支持</td></tr></tbody></table><h3 id="兼容代码"><a href="#兼容代码" class="headerlink" title="兼容代码"></a>兼容代码</h3><blockquote><p>待善对中文的兼容</p></blockquote><ul><li><p>encode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function encode(text)&#123;</span><br><span class="line">     const textString = String(text),</span><br><span class="line">        textArray = textString.split(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">     for (let i = 0; i &lt; textArray.length; i++) &#123;</span><br><span class="line">        textArray[i] = textArray[i].charCodeAt(0)</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     return new Uint8Array(textArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/171228/dHd1BF0IDh.png?imageslim" alt="mark"></p></li><li><p>decode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function decode(textBuffer)&#123;</span><br><span class="line">    const textArray = Array.from(new Uint8Array(textBuffer)),</span><br><span class="line">        textHex = textArray.map(b =&gt; (&apos;00&apos; + b.toString(16)).slice(-2)).join(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">    return unescape(textHex.replace(/(..)/g,&quot;%$1&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oyzpu0yr9.bkt.clouddn.com/blog/171228/IFG8F3B98K.png?imageslim" alt="mark"></p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developers.google.com/web/updates/2014/08/Easier-ArrayBuffer-String-conversion-with-the-Encoding-API" target="_blank" rel="noopener">Easier ArrayBuffer to String conversion with the Encoding API</a></li><li><a href="https://encoding.spec.whatwg.org/" target="_blank" rel="noopener">spec</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/TextDecoder" target="_blank" rel="noopener">MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TextEncoder&quot;&gt;&lt;a href=&quot;#TextEncoder&quot; class=&quot;headerlink&quot; title=&quot;TextEncoder&quot;&gt;&lt;/a&gt;TextEncoder&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构造函数&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="javascript" scheme="https://hexuanzhang.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://hexuanzhang.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>二进制数组</title>
    <link href="https://hexuanzhang.github.io/2017/12/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%BB%84/"/>
    <id>https://hexuanzhang.github.io/2017/12/25/二进制数组/</id>
    <published>2017-12-25T10:53:12.000Z</published>
    <updated>2017-12-26T13:18:24.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h2><blockquote><p>  <code>ArrayBuffer</code> 对象、<code>TypedArray</code> 视图和 <code>DataView</code> 视图是 JavaScript 以数组的语法操作二进制数据接口，也叫二进制数组；这些接口设计的初衷是为了满足浏览器与显卡通信时大量实时的数据交换</p><p>  二进制数组并非真正的数组，而是类数组对象</p><p>  ES6 将二进制数组纳入规范，并增加了新的方法</p></blockquote><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><blockquote><p>  JavaScript 类型数组（<code>Typed Arrays</code>）将实现拆分为缓冲和视图两部分。一个缓冲（由 <code>ArrayBuffer</code> 对象实现）描述的是一个数据块。缓冲没有格式且不提供机制访问其内容；</p><p>  为了访问缓冲对象中包含的内存，需要使用视图；视图提供了上下文 — 即数据类型、起始偏移量和元素数 — 将数据转换为实际有类型的数组</p><p>  类型数组包含两种视图，一种是  <code>TypedArray</code> 视图，另一种是 <code>DataView</code> 视图；前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型</p></blockquote><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a></h3><blockquote><p>  <code>ArrayBuffer</code> 是一种数据类型，用来表示一个通用的、固定长度的二进制数据缓冲区；这段缓冲区内容无法直接读写，只能通过 <code>TypedArray</code> 或 <code>DataView</code> 以指定格式解读这段二进制数据</p><p>  <code>ArrayBuffer</code> 也是构造函数，可以分配一段存储数据的连续内存区域；构造函数的参数代表的是所需内存大小（单位为字节），每个字节默认值均为 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(32);</span><br></pre></td></tr></table></figure><h4 id="方法和属性"><a href="#方法和属性" class="headerlink" title="方法和属性"></a>方法和属性</h4><ul><li><p>byteLength</p><blockquote><p>  返回所分配的内存区域的字节长度</p><p>  需要检查是否分配成功；如果待分配的内存区域过大，有可能分配失败（没有足够多的连续空余内存）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(32);</span><br><span class="line">buffer.byteLength; // 32</span><br><span class="line"></span><br><span class="line">if (buffer.byteLength === n) &#123;</span><br><span class="line">    // 分配成功</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 分配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>slice()</p><blockquote><p>  截取原 <code>ArrayBuffer</code> 对象，生成一份新的 <code>ArrayBuffer</code> 对象</p><p>  该方法参数与数组 <code>slice</code> 一致，第一个参数指截取开始位置，第二个参数指的是截取结束位置（不包含）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(32);</span><br><span class="line">const newBuffer = buffer.slice(0, 3);</span><br></pre></td></tr></table></figure></li><li><p>ArrayBuffer.isView()</p><blockquote><p>  此方法为 <code>ArrayBuffer</code> 静态方法，判断参数是否为 <code>TypedArray</code> 或 <code>DataView</code> 实例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(32);</span><br><span class="line">ArrayBuffer.isView(buffer);</span><br><span class="line"></span><br><span class="line">const v = new Int32Array(buffer);</span><br><span class="line">ArrayBuffer.isView(v);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-26-082919.jpg" alt=""></p></li></ul><h3 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noopener">TypedArray</a></h3><blockquote><p>  <code>TypedArray</code> 包括 9 种类型，每一种类型都是一种构造函数</p></blockquote><table><thead><tr><th>类型</th><th>描述</th><th>取值范围</th><th>长度</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array" target="_blank" rel="noopener">Int8Array</a></td><td>8 位有符号整数</td><td>-128 ~ 127</td><td>1</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" target="_blank" rel="noopener">Uint8Array</a></td><td>8 位无符号整数</td><td>0 ~ 255</td><td>1</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray" target="_blank" rel="noopener">Uint8ClampedArray</a></td><td>8 位无符号整数（溢出处理不同）</td><td>0 ~ 255</td><td>1</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array" target="_blank" rel="noopener">Int16Array</a></td><td>16 位有符号整数</td><td>-32768 ~ 32767</td><td>2</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array" target="_blank" rel="noopener">Uint16Array</a></td><td>16 位无符号整数</td><td>0 ~ 65535</td><td>2</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array" target="_blank" rel="noopener">Int32Array</a></td><td>32 位有符号整数</td><td>-2147483638 ~ 213647483647</td><td>4</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array" target="_blank" rel="noopener">Uint32Array</a></td><td>32 位无符号整数</td><td>0 ~ 4294967295</td><td>4</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array" target="_blank" rel="noopener">Float32Array</a></td><td>32 位浮点数</td><td>1.2x10-38 ~ 3.4x1038</td><td>4</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array" target="_blank" rel="noopener">Float64Array</a></td><td>64 位浮点数</td><td>5.0x10-324 ~ 1.8x10308</td><td>8</td></tr></tbody></table><h4 id="普通数组与-TypedArray-数组差异"><a href="#普通数组与-TypedArray-数组差异" class="headerlink" title="普通数组与 TypedArray 数组差异"></a>普通数组与 TypedArray 数组差异</h4><ul><li>TypedArray 数组的所有成员都是同一种类型</li><li>TypedArray 数组的成员是连续的</li><li>TypedArray 数组成员的默认值为 0</li><li>TypedArray 数组只是一层视图，本身不储存数据，数据都储存在底层 <code>ArrayBuffer</code> 对象之中</li><li>TypedArray 数组包含的方法与普通数组基本一致，唯一特殊的是没有 <code>concat</code> 方法</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>TypedArray</code> 数组提供 9 种构造函数，用来生成相应类型的数组实例。<br>下面是构造函数的各种用法：</p><ul><li><p>TypedArray(buffer, byteOffset=0, length?)</p><blockquote><p>  第一个参数为必需，指 <code>ArrayBuffer</code> 对象，后面两个参数分别是开始和结束位置，默认从 0  开始到最大长度</p><p>  <strong>根据同一 <code>ArrayBuffer</code> 对象创建多个 <code>TypedArray</code> 时，对任何一个类型数组进行修改，都会影响其它类型数组，因为类型数组只是视图</strong></p><p>  <strong>创建不同类型的类型数组时，<code>byteOffset</code> 参数有相应的字节倍数限制，如：Int16Array 类型数组是 4 字节，因而 <code>byteOffset</code> 只能为 4 的倍数</strong>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(8);</span><br><span class="line"></span><br><span class="line">const buff_16 = new Uint16Array(buffer);</span><br><span class="line">const buff_32 = new Int32Array(buffer);</span><br><span class="line"></span><br><span class="line">buff_16[0] = 10;</span><br><span class="line">buff_16[1] = 11;</span><br><span class="line"></span><br><span class="line">console.log(buff_16);</span><br><span class="line">console.log(buff_32);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-26-082920.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(8);</span><br><span class="line"></span><br><span class="line">console.log(new Int8Array(buffer, 1)); // ​​​​​Int8Array &#123; [Iterator]  &apos;0&apos;: 0, &apos;1&apos;: 0, &apos;2&apos;: 0, &apos;3&apos;: 0, &apos;4&apos;: 0, &apos;5&apos;: 0, &apos;6&apos;: 0 &#125;​​​​​</span><br><span class="line"></span><br><span class="line">new Int16Array(buffer, 1); // ​​start offset of Int16Array should be a multiple of 2​​</span><br><span class="line">console.log(new Int16Array(buffer, 2)); // ​​​​​Int16Array &#123; [Iterator]  &apos;0&apos;: 0, &apos;1&apos;: 0, &apos;2&apos;: 0 &#125;​​​​​</span><br><span class="line"></span><br><span class="line">new Int32Array(buffer, 2); ​​// start offset of Int32Array should be a multiple of 4​​</span><br><span class="line">console.log(new Int32Array(buffer, 4)); // ​​​​​Int32Array &#123; [Iterator]  &apos;0&apos;: 0 &#125;​​​​​</span><br><span class="line"></span><br><span class="line">new Float32Array(buffer, 2); ​​// ​​start offset of Float32Array should be a multiple of 4​​</span><br><span class="line">console.log(new Float32Array(buffer, 4)); // ​​​​​Float32Array &#123; [Iterator]  &apos;0&apos;: 0 &#125;​​​​​</span><br><span class="line"></span><br><span class="line">new Float64Array(buffer, 4); // ​​start offset of Float64Array should be a multiple of 8​​</span><br><span class="line">console.log(new Float64Array(buffer)); // ​​​​​Float64Array &#123; [Iterator]  &apos;0&apos;: 0 &#125;​​​​​</span><br><span class="line">console.log(new Float64Array(buffer, 8)); ​​​​​// Float64Array &#123; [Iterator] &#125;​​​​​</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>TypedArray(length)</p><blockquote><p>  也可以不通过 <code>ArrayBuffer</code> 对象，直接分配内存长度，再进行赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const buff_8 = new Int8Array(8);</span><br><span class="line"></span><br><span class="line">buff_8[0] = 1;</span><br><span class="line">buff_8[1] = 2;</span><br><span class="line"></span><br><span class="line">console.log(buff_8);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-26-082921.jpg" alt=""></p></li><li><p>TypedArray(typedArray)</p><blockquote><p>  还可以接受另外一个 <code>TypedArray</code> 实例作为参数，生成新的 <code>TypedArray</code> 类型数组</p><p>  新生成的 <code>TypedArray</code> 数组只是复制了原数组的值，对应底层 <code>ArrayBuffer</code> 不一样；<strong>新数组生成时也会创建新的 <code>ArrayBuffer</code> 对象存储数据，不会在原数组的 <code>ArrayBuffer</code> 对象上建立视图</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const buff_8 = new Int8Array(2);</span><br><span class="line">const buff8 = new Int8Array(buff_8);</span><br><span class="line"></span><br><span class="line">buff_8[0] = 1;</span><br><span class="line">buff8[0] = 2;</span><br><span class="line"></span><br><span class="line">console.log(buff_8);</span><br><span class="line">console.log(buff8);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-26-082922.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 基于同一 ArrayBuffer 建立视图</span><br><span class="line">const buff_8 = new Int8Array([1, 2]);</span><br><span class="line">const buff8 = new Int8Array(buff_8.buffer);</span><br><span class="line"></span><br><span class="line">console.log(buff_8[0]); </span><br><span class="line">console.log(buff8[0]);</span><br><span class="line"></span><br><span class="line">buff_8[0] = 2;</span><br><span class="line">console.log(buff8[0]);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-26-082924.jpg" alt=""></p></li><li><p>TypedArray(array)</p><blockquote><p>  构造函数的参数也可以是一个普通数组或类数组，然后直接生成 <code>TypedArray</code> 实例</p><p>  此时 <code>TypedArray</code> 视图不会在原数组的内存上建立视图，会重新创建 <code>ArrayBuffer</code> 对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const buff_8 = new Int8Array([1, 2, 3]);</span><br><span class="line">console.log(buff_8);</span><br><span class="line"></span><br><span class="line">const buff_16 = new Int16Array(&#123; length: 2, 0: 0, 1: 2&#125;);</span><br><span class="line">console.log(buff_16);</span><br></pre></td></tr></table></figure><p><img src="http://blog-1255677601.cossh.myqcloud.com/blog/2017-12-26-82925.jpg" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二进制数组&quot;&gt;&lt;a href=&quot;#二进制数组&quot; class=&quot;headerlink&quot; title=&quot;二进制数组&quot;&gt;&lt;/a&gt;二进制数组&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  &lt;code&gt;ArrayBuffer&lt;/code&gt; 对象、&lt;code&gt;TypedArra
      
    
    </summary>
    
      <category term="javascript" scheme="https://hexuanzhang.github.io/categories/javascript/"/>
    
      <category term="ES6" scheme="https://hexuanzhang.github.io/categories/javascript/ES6/"/>
    
    
      <category term="javascript" scheme="https://hexuanzhang.github.io/tags/javascript/"/>
    
      <category term="ES6" scheme="https://hexuanzhang.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
